---
title: "48_predmet19to20_OneOut"
author: "Hayato Yoshioka"
date: "2023-05-29"
output: html_document
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(eval = TRUE)
```


## 2.1 Model Build for 2020 Met Prediction 
Oneout 45 ver2
Inter and inner year prediction by BLUP   
Drought and Control
We tried the following models     
- G -> Met  (2019->2020)  
- G + Micro -> Met (2019->2020)  
- G + Micro -> Met (2020->2020)  

required packages
```{r, message =F}
require(BGLR)
require(here)
require(ggplot2)
require(reshape2)
require(gridExtra)
library(readr)
library(stringr)
library(ggsci)
library(RAINBOWR)
library(lubridate)
library(foreach)
library(future)
library(doFuture)
library(doRNG)
library(tictoc)
library(doSNOW)
```

seed
```{r, message =F}
# save or read the seed
seedIndCsv <-  here("out","seedInd.csv")
if (file.exists(seedIndCsv)) {
  seedInd <- read.csv(seedIndCsv, row.names = 1, header = T)
  seedInd <- c(as.matrix(seedInd))
} else {
  seedInd <- sample(1:500, 10, replace = F)
  write.csv(x = seedInd, file =  here("out","seedInd.csv"))
}
```

read phenotypic data
```{r}
pheno18 <- read.csv(here("2018", "shoot_blup_all_2018.csv"), row.names = 1)
pheno19 <- read.csv(here("2019", "shoot_blup_all_2019.csv"), row.names = 1)
pheno20 <- read.csv(here("2020", "shoot_blup_all_2020.csv"), row.names = 1)

plot18<-rownames(pheno18)
plot19<-rownames(pheno19)
plot20<-rownames(pheno20)

var18<-pheno18$var.id
var19<-pheno19$var.id
var20<-pheno20$var.id
```

read genomic relationship matrix data
```{r}
grm <- readRDS(here("data", "grm_2.rds"))
head(grm)[,1:3]
```

read metabolomic data
```{r}
met<- read.csv(here("2019","2019_Tottori_Jul_RootMetabolome_X.csv"))
rownames(met) <- paste0(substr(as.matrix(met[7]),1,2),".",sprintf("%03d",as.matrix(met[8])))
met19 <- met[,10:ncol(met)]
colnames(met19)<- sub("M","X",colnames(met19))

met <- read.csv(here("2020", "2020_Tottori_Main_RootMetabolome.csv"))
rownames(met) <- paste0(substr(as.matrix(met[7]),1,2),".",sprintf("%03d",as.matrix(met[8])))
met20 <- met[,10:ncol(met)]

s_c <- colnames(met19) %in% colnames(met20)
met19<- met19[,s_c]
s_c <- colnames(met20) %in% colnames(met19)
met20<- met20[,s_c]
#table(colnames(met20) == colnames(met19))
```

read microbiome rarificated data
```{r}
com <- read.table(here("2018", "table-from-biom-7-2018-after.txt"), row.names = 1)
rownames(com) <- gsub(";",".",rownames(com))
com18<- com
colnames(com18) <- cbind(plot18[201:400],plot18[601:800])

com <- read.csv(here("2019", "table-from-biom-7.csv"), row.names = 1)
rownames(com) <- gsub(";",".",rownames(com))
com19<- com

#comriken <- read.csv(here("2020", "table-from-biom-7-2020-after.csv"))
com <- read.csv(here("2020", "2020_Tottori_Main_Microbiome_Ratio.csv"))
rownames(com) <- paste0(substr(as.matrix(com[7]),1,2),".",sprintf("%03d",as.matrix(com[8])))
com <- com[,10:ncol(com)]
com20 <- t(com)

#s_c <- rownames(com19) %in% rownames(com20)
#com19<- com19[s_c,]
#s_c <- rownames(com20) %in% rownames(com19)
#com20<- com20[s_c,]

s_c <- (rownames(com19) %in% rownames(com20)) & (rownames(com19) %in% rownames(com18))
com19<- com19[s_c,]
s_c <- rownames(com20) %in% rownames(com19)
com20<- com20[s_c,]
s_c <- rownames(com18) %in% rownames(com20)
com18<- com18[s_c,]

dim(com18)
dim(com19)
dim(com20)
```


### Drought

```{r}
CD ="W4"
```


select the lines which has pheno, grm, met, micro data in 2019 and 2020
```{r}
selector.grm1 <- pheno18$var.id %in% rownames(grm)
selector.com1 <-rownames(pheno18) %in% colnames(com18)

selector.grm2 <- pheno19$var.id %in% rownames(grm)
selector.com2 <-rownames(pheno19) %in% colnames(com19)

selector.grm3 <- pheno20$var.id %in% rownames(grm)
selector.com3 <-rownames(pheno20) %in% colnames(com20)


pl<- list(pheno18,pheno19,pheno20)
pl.sel<- list()

for (i in 2:3){
pheno<- pl[[i]]

if (i==1) {
  selector.grm <- selector.grm1
  selector.com <- selector.com1
}

else if (i==2) {
  selector.grm <- selector.grm2
  selector.com <- selector.com2
}

else if (i==3) {
  selector.grm <- selector.grm3
  selector.com <- selector.com3
}


pheno.sel <- pheno[selector.grm & selector.com, ]
#head(pheno.sel)
print(dim(pheno.sel))

selector.cd <- substr(rownames(pheno.sel), 1, 2) == CD 
pheno.sel.cd <- pheno.sel[selector.cd, ]
dim(pheno.sel.cd)

plot.id <- rownames(pheno.sel.cd)
rownames(pheno.sel.cd)<-pheno.sel.cd$var.id
pheno.sel.cd$var.id <- plot.id
colnames(pheno.sel.cd)[1]<- "plot.id"
sg <- rownames(grm) %in% rownames(pheno.sel.cd)
gv<-rownames(grm[sg,sg])
pheno.sel.cd<- pheno.sel.cd[gv,]
print(dim(pheno.sel.cd))
pl.sel[[i]]<- pheno.sel.cd
}

#psc18<-  pl.sel[[1]]
psc19<-  pl.sel[[2]] 
psc20<-  pl.sel[[3]]



s_p <- rownames(psc19) %in% rownames(psc20)
psc19<- psc19[s_p,]
s_p <- rownames(psc20) %in% rownames(psc19)
psc20<- psc20[s_p,]

s_p <- colnames(psc19) %in% colnames(psc20)
psc19<- psc19[,s_p]
s_p <- colnames(psc20) %in% colnames(psc19)
psc20<- psc20[,s_p]

table(rownames(psc19) == rownames(psc20))

```




2019 
```{r}
var.id <- rownames(psc19)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc19$plot.id
com19.cd <- t(com19[, plot.id])
com19.cd <- scale(com19.cd[, apply(com19.cd, 2, sd) > 0])
#met19ns.cd <- met19[plot.id, ]
met19.cd <- scale(met19[plot.id, ])
```

2020
```{r, message =F}
var.id <- rownames(psc20)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc20$plot.id
com20.cd <- t(com20[, plot.id])
com20.cd <- scale(com20.cd[, apply(com20.cd, 2, sd) > 0])
#met20ns.cd <- met20[plot.id, ]
met20.cd <- scale(met20[plot.id, ])
```

Integrate + RM
```{r, message =F}
psc <- rbind(psc19,psc20)

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

mrm19.cd <- tcrossprod(com19.cd) / ncol(com19.cd)
mrm20.cd <- tcrossprod(com20.cd) / ncol(com20.cd)

com.cd<- rbind(com19.cd,com20.cd)
rownames(com.cd)<-rownames(psc)
mrm.cd <- tcrossprod(com.cd) / ncol(com.cd)

metrm19.cd <- tcrossprod(met19.cd) / ncol(met19.cd)
metrm20.cd <- tcrossprod(met20.cd) / ncol(met20.cd)

#metns.cd <- rbind(met19ns.cd,met20ns.cd)
met.cd<- rbind(met19.cd,met20.cd)
rownames(met.cd)<-rownames(psc)
metrm.cd <- tcrossprod(met.cd) / ncol(met.cd)
```

###20192020model
Kernel & Z
```{r, message =F}
K1 <- cbind(rbind(grm.cd,grm.cd),rbind(grm.cd,grm.cd))
K2 <- mrm.cd

Z <- design.Z(pheno.labels = rownames(psc),geno.names = rownames(psc))

KZ1<- list(A= list(K = K1, Z = Z))
KZ2<- list(A= list(K = K2, Z = Z))
KZ12<- list(A= list(K = K1, Z = Z),B= list(K = K2, Z = Z))

```

### Model Run GM
```{R,eval = TRUE}

y <- met.cd

ZETA <- KZ12
X0 <- NULL
iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y)/2)
  
  for (t in 1:nrow(y)/2) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    yNa[(nrow(y)/2+1):nrow(y)] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0,
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[(nrow(y)/2+t)]
  }
   return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()

# resEM3$weights
predmetgm<-t(xr)
rownames(predmetgm) <- var.id
colnames(predmetgm) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])


See(predmetgm)

```

```{R,eval = TRUE}
write.csv(predmetgm,here("out","20f19_predmet_GM_blup_OneOut.csv"))
```

### Model Run G
```{R,eval = TRUE}
y <- met.cd

ZETA <- KZ1
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr2 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
#xr <- foreach(i = 1:2,.combine="rbind") %dopar% {

  trait.name <- colnames(y)[i]
  
  
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y)/2)
  
  for (t in 1:nrow(y)/2) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    yNa[(nrow(y)/2+1):nrow(y)] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[(nrow(y)/2+t)]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()
# resEM3$weights
predmetg<-t(xr2)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,eval = TRUE}
write.csv(predmetg,here("out","20f19_predmet_G_blup_OneOut.csv"))
```

### Model Run M
```{R,eval = TRUE}
y <- met.cd

ZETA <- KZ2
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr2 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
#xr <- foreach(i = 1:2,.combine="rbind") %dopar% {

  trait.name <- colnames(y)[i]
  
  
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y)/2)
  
  for (t in 1:nrow(y)/2) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    yNa[(nrow(y)/2+1):nrow(y)] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[(nrow(y)/2+t)]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()
# resEM3$weights
predmetg<-t(xr2)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,eval = TRUE}
write.csv(predmetg,here("out","20f19_predmet_M_blup_OneOut.csv"))
```

### 20 in 20 Model Run GM
```{R,eval = TRUE}

K1 <- grm.cd
K2 <- mrm20.cd

Z <- design.Z(pheno.labels = rownames(grm.cd),geno.names = rownames(grm.cd))

KZ1<- list(A= list(K = K1, Z = Z))
KZ2<- list(A= list(K = K2, Z = Z))
KZ12<- list(A= list(K = K1, Z = Z),B= list(K = K2, Z = Z))

y <- met20.cd

ZETA <- KZ12
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr3 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
 
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y))
  
  for (t in 1:nrow(y)) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, n.core = 1, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[t]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()


# resEM3$weights
predmetg<-t(xr3)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,fig.dim = c(5,3)}
write.csv(predmetg,here("out","20f20_predmet_GM_blup_OneOut.csv"))
```


### 20 in 20 Model Run G
```{R,eval = TRUE}

K1 <- grm.cd

Z <- design.Z(pheno.labels = rownames(grm.cd),geno.names = rownames(grm.cd))

KZ1<- list(A= list(K = K1, Z = Z))

y <- met20.cd

ZETA <- KZ1
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr3 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
 
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y))
  
  for (t in 1:nrow(y)) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, n.core = 1, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[t]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()


# resEM3$weights
predmetg<-t(xr3)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,fig.dim = c(5,3)}
write.csv(predmetg,here("out","20f20_predmet_G_blup_OneOut.csv"))
```


### hist all
```{R}

myvector <- c(
  "20f19_predmet_G_blup_OneOut.csv",
  "20f19_predmet_M_blup_OneOut.csv",
  "20f19_predmet_GM_blup_OneOut.csv",
  "20f20_predmet_GM_blup_OneOut.csv"
  
)
sapply(myvector,met20.cd, FUN = histfunction)

```

### Control
```{r}
CD ="W1"
```

select the lines which has pheno, grm, met, micro data in 2019 and 2020
```{r}
selector.grm1 <- pheno18$var.id %in% rownames(grm)
selector.com1 <-rownames(pheno18) %in% colnames(com18)

selector.grm2 <- pheno19$var.id %in% rownames(grm)
selector.com2 <-rownames(pheno19) %in% colnames(com19)

selector.grm3 <- pheno20$var.id %in% rownames(grm)
selector.com3 <-rownames(pheno20) %in% colnames(com20)


pl<- list(pheno18,pheno19,pheno20)
pl.sel<- list()

for (i in 2:3){
pheno<- pl[[i]]

if (i==1) {
  selector.grm <- selector.grm1
  selector.com <- selector.com1
}

else if (i==2) {
  selector.grm <- selector.grm2
  selector.com <- selector.com2
}

else if (i==3) {
  selector.grm <- selector.grm3
  selector.com <- selector.com3
}


pheno.sel <- pheno[selector.grm & selector.com, ]
#head(pheno.sel)
print(dim(pheno.sel))

selector.cd <- substr(rownames(pheno.sel), 1, 2) == CD 
pheno.sel.cd <- pheno.sel[selector.cd, ]
dim(pheno.sel.cd)

plot.id <- rownames(pheno.sel.cd)
rownames(pheno.sel.cd)<-pheno.sel.cd$var.id
pheno.sel.cd$var.id <- plot.id
colnames(pheno.sel.cd)[1]<- "plot.id"
sg <- rownames(grm) %in% rownames(pheno.sel.cd)
gv<-rownames(grm[sg,sg])
pheno.sel.cd<- pheno.sel.cd[gv,]
print(dim(pheno.sel.cd))
pl.sel[[i]]<- pheno.sel.cd
}

#psc18<-  pl.sel[[1]]
psc19<-  pl.sel[[2]] 
psc20<-  pl.sel[[3]]

s_p <- rownames(psc19) %in% rownames(psc20)
psc19<- psc19[s_p,]
s_p <- rownames(psc20) %in% rownames(psc19)
psc20<- psc20[s_p,]

s_p <- colnames(psc19) %in% colnames(psc20)
psc19<- psc19[,s_p]
s_p <- colnames(psc20) %in% colnames(psc19)
psc20<- psc20[,s_p]

table(rownames(psc19) == rownames(psc20))

```

2019 
```{r}
var.id <- rownames(psc19)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc19$plot.id
com19.cd <- t(com19[, plot.id])
com19.cd <- scale(com19.cd[, apply(com19.cd, 2, sd) > 0])
#met19ns.cd <- met19[plot.id, ]
met19.cd <- scale(met19[plot.id, ])
```

2020
```{r, message =F}
var.id <- rownames(psc20)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc20$plot.id
com20.cd <- t(com20[, plot.id])
com20.cd <- scale(com20.cd[, apply(com20.cd, 2, sd) > 0])
#met20ns.cd <- met20[plot.id, ]
met20.cd <- scale(met20[plot.id, ])
```

Integrate + RM
```{r, message =F}
psc <- rbind(psc19,psc20)

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

mrm19.cd <- tcrossprod(com19.cd) / ncol(com19.cd)
mrm20.cd <- tcrossprod(com20.cd) / ncol(com20.cd)

com.cd<- rbind(com19.cd,com20.cd)
rownames(com.cd)<-rownames(psc)
mrm.cd <- tcrossprod(com.cd) / ncol(com.cd)

metrm19.cd <- tcrossprod(met19.cd) / ncol(met19.cd)
metrm20.cd <- tcrossprod(met20.cd) / ncol(met20.cd)

#metns.cd <- rbind(met19ns.cd,met20ns.cd)
met.cd<- rbind(met19.cd,met20.cd)
rownames(met.cd)<-rownames(psc)
metrm.cd <- tcrossprod(met.cd) / ncol(met.cd)
```


###20192020model
Kernel & Z
```{r, message =F}
K1 <- cbind(rbind(grm.cd,grm.cd),rbind(grm.cd,grm.cd))
K2 <- mrm.cd

Z <- design.Z(pheno.labels = rownames(psc),geno.names = rownames(psc))

KZ1<- list(A= list(K = K1, Z = Z))
KZ2<- list(A= list(K = K2, Z = Z))
KZ12<- list(A= list(K = K1, Z = Z),B= list(K = K2, Z = Z))

```


### Model Run GM

```{R,eval = TRUE}

y <- met.cd

ZETA <- KZ12
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
#xr <- foreach(i = 1:2,.combine="rbind") %dopar% {

  trait.name <- colnames(y)[i]
  
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y)/2)
  
  for (t in 1:nrow(y)/2) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    yNa[(nrow(y)/2+1):nrow(y)] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0,
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[(nrow(y)/2+t)]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()

# resEM3$weights
predmetgm<-t(xr)
rownames(predmetgm) <- var.id
colnames(predmetgm) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])


See(predmetgm)


```


```{R,eval = TRUE}
write.csv(predmetgm,here("out","20f19_predmet_GM_blup_OneOut_c.csv"))
```

### Model Run G

```{R,eval = TRUE}
y <- met.cd

ZETA <- KZ1
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr2 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
#xr <- foreach(i = 1:2,.combine="rbind") %dopar% {

  trait.name <- colnames(y)[i]

  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y)/2)
  
  for (t in 1:nrow(y)/2) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    yNa[(nrow(y)/2+1):nrow(y)] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[(nrow(y)/2+t)]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()
# resEM3$weights
predmetg<-t(xr2)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,eval = TRUE}
write.csv(predmetg,here("out","20f19_predmet_G_blup_OneOut_c.csv"))
```


### 20 in 20 Model

```{R,eval = TRUE}

K1 <- grm.cd
K2 <- mrm20.cd

Z <- design.Z(pheno.labels = rownames(grm.cd),geno.names = rownames(grm.cd))

KZ1<- list(A= list(K = K1, Z = Z))
KZ2<- list(A= list(K = K2, Z = Z))
KZ12<- list(A= list(K = K1, Z = Z),B= list(K = K2, Z = Z))

```

Model Run GM
```{R}

y <- met20.cd

ZETA <- KZ12
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr3 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
 
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y))
  
  for (t in 1:nrow(y)) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, n.core = 1, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[t]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()
# resEM3$weights
predmetg<-t(xr3)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,fig.dim = c(5,3)}
write.csv(predmetg,here("out","20f20_predmet_GM_blup_OneOut_c.csv"))
```


Model Run G
```{R}

y <- met20.cd

ZETA <- KZ1
X0 <- NULL

iterations=ncol(y)

cl <- makeCluster(10)
registerDoSNOW(cl)
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

tic()
xr3 <- foreach(i = 1:iterations,.combine="rbind",.options.snow = opts,.export = "EM3.cpp") %dopar% {
 
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y))
  
  for (t in 1:nrow(y)) { 
  #for (t in 1) {
    
    yNa <- y[,i]
    yNa[t] <- NA
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, n.core = 1, 
                      ZETA = ZETA)
    # input the predicted data
    predictionDataRAINBOW[t] <- resEM3$y.pred[t]
  }
  return(predictionDataRAINBOW)
  
} 
close(pb)
stopCluster(cl) 

toc()
# resEM3$weights
predmetg<-t(xr3)
rownames(predmetg) <- var.id
colnames(predmetg) <- colnames(y)
obsData <- (y[(nrow(y)/2+1):nrow(y),i])

See(predmetg)

```

csv
```{R,fig.dim = c(5,3)}
write.csv(predmetg,here("out","20f20_predmet_G_blup_OneOut_c.csv"))
```

### hist all
```{R}

myvector <- c(
  "20f19_predmet_G_blup_OneOut_c.csv",
  "20f19_predmet_GM_blup_OneOut_c.csv",
  "20f20_predmet_GM_blup_OneOut_c.csv"
)
sapply(myvector,met20.cd, FUN = histfunction)

```
