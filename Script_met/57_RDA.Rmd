---
title: "57_RDA_Test"
output: html_document
date: "2023-10-19"
---

required packages
```{r, message =F}
require(BGLR)
require(here)
require(ggplot2)
require(reshape2)
require(gridExtra)
library(readr)
library(stringr)
library(ggsci)
library(RAINBOWR)
library(lubridate)
library(foreach)
library(future)
library(doFuture)
library(doRNG)
library(tictoc)
library(doSNOW)
library(purrr)
source("MyFunctions.R")
library(vegan)
library(VARshrink)
library(ggplot2)
library(glmnet)
library(lars)

```

seed
```{r, message =F}
# save or read the seed
seedIndCsv <-  here("out","seedInd.csv")
if (file.exists(seedIndCsv)) {
  seedInd <- read.csv(seedIndCsv, row.names = 1, header = T)
  seedInd <- c(as.matrix(seedInd))
} else {
  seedInd <- sample(1:500, 10, replace = F)
  write.csv(x = seedInd, file =  here("out","seedInd.csv"))
}
```

read phenotypic data
```{r}
pheno18 <- read.csv(here("2018", "shoot_blup_all_2018.csv"), row.names = 1)
pheno19 <- read.csv(here("2019", "shoot_blup_all_2019.csv"), row.names = 1)
pheno20 <- read.csv(here("2020", "shoot_blup_all_2020.csv"), row.names = 1)

plot18<-rownames(pheno18)
plot19<-rownames(pheno19)
plot20<-rownames(pheno20)

var18<-pheno18$var.id
var19<-pheno19$var.id
var20<-pheno20$var.id
```
read genomic relationship matrix data
```{r}
grm <- readRDS(here("data", "grm_2.rds"))
head(grm)[,1:3]
```

read metabolomic data
```{r}
met<- read.csv(here("2019","2019_Tottori_Jul_RootMetabolome_X.csv"))
rownames(met) <- paste0(substr(as.matrix(met[7]),1,2),".",sprintf("%03d",as.matrix(met[8])))
met19 <- met[,10:ncol(met)]
colnames(met19)<- sub("M","X",colnames(met19))

met <- read.csv(here("2020", "2020_Tottori_Main_RootMetabolome.csv"))
rownames(met) <- paste0(substr(as.matrix(met[7]),1,2),".",sprintf("%03d",as.matrix(met[8])))
met20 <- met[,10:ncol(met)]

s_c <- colnames(met19) %in% colnames(met20)
met19<- met19[,s_c]
s_c <- colnames(met20) %in% colnames(met19)
met20<- met20[,s_c]
#table(colnames(met20) == colnames(met19))
```

read microbiome rarificated data
```{r}
com <- read.table(here("2018", "table-from-biom-7-2018-after.txt"), row.names = 1)
rownames(com) <- gsub(";",".",rownames(com))
com18<- com
colnames(com18) <- cbind(plot18[201:400],plot18[601:800])

com <- read.csv(here("2019", "table-from-biom-7.csv"), row.names = 1)
rownames(com) <- gsub(";",".",rownames(com))
com19<- com

#comriken <- read.csv(here("2020", "table-from-biom-7-2020-after.csv"))
com <- read.csv(here("2020", "2020_Tottori_Main_Microbiome_Ratio.csv"))
rownames(com) <- paste0(substr(as.matrix(com[7]),1,2),".",sprintf("%03d",as.matrix(com[8])))
com <- com[,10:ncol(com)]
com20 <- t(com)

#s_c <- rownames(com19) %in% rownames(com20)
#com19<- com19[s_c,]
#s_c <- rownames(com20) %in% rownames(com19)
#com20<- com20[s_c,]

s_c <- (rownames(com19) %in% rownames(com20)) & (rownames(com19) %in% rownames(com18))
com19<- com19[s_c,]
s_c <- rownames(com20) %in% rownames(com19)
com20<- com20[s_c,]
s_c <- rownames(com18) %in% rownames(com20)
com18<- com18[s_c,]

dim(com18)
dim(com19)
dim(com20)
```


### Drought

```{r}
CD ="W4"
```


select the lines which has pheno, grm, met, micro data in 2019 and 2020
```{r}
selector.grm1 <- pheno18$var.id %in% rownames(grm)
selector.com1 <-rownames(pheno18) %in% colnames(com18)

selector.grm2 <- pheno19$var.id %in% rownames(grm)
selector.com2 <-rownames(pheno19) %in% colnames(com19)

selector.grm3 <- pheno20$var.id %in% rownames(grm)
selector.com3 <-rownames(pheno20) %in% colnames(com20)


pl<- list(pheno18,pheno19,pheno20)
pl.sel<- list()

for (i in 2:3){
pheno<- pl[[i]]

if (i==1) {
  selector.grm <- selector.grm1
  selector.com <- selector.com1
}

else if (i==2) {
  selector.grm <- selector.grm2
  selector.com <- selector.com2
}

else if (i==3) {
  selector.grm <- selector.grm3
  selector.com <- selector.com3
}


pheno.sel <- pheno[selector.grm & selector.com, ]
#head(pheno.sel)
print(dim(pheno.sel))

selector.cd <- substr(rownames(pheno.sel), 1, 2) == CD 
pheno.sel.cd <- pheno.sel[selector.cd, ]
dim(pheno.sel.cd)

plot.id <- rownames(pheno.sel.cd)
rownames(pheno.sel.cd)<-pheno.sel.cd$var.id
pheno.sel.cd$var.id <- plot.id
colnames(pheno.sel.cd)[1]<- "plot.id"
sg <- rownames(grm) %in% rownames(pheno.sel.cd)
gv<-rownames(grm[sg,sg])
pheno.sel.cd<- pheno.sel.cd[gv,]
print(dim(pheno.sel.cd))
pl.sel[[i]]<- pheno.sel.cd
}

#psc18<-  pl.sel[[1]]
psc19<-  pl.sel[[2]] 
psc20<-  pl.sel[[3]]



s_p <- rownames(psc19) %in% rownames(psc20)
psc19<- psc19[s_p,]
s_p <- rownames(psc20) %in% rownames(psc19)
psc20<- psc20[s_p,]

s_p <- colnames(psc19) %in% colnames(psc20)
psc19<- psc19[,s_p]
s_p <- colnames(psc20) %in% colnames(psc19)
psc20<- psc20[,s_p]

table(rownames(psc19) == rownames(psc20))

```


2019 
```{r}
var.id <- rownames(psc19)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc19$plot.id
com19.cd <- t(com19[, plot.id])
com19.cd <- scale(com19.cd[, apply(com19.cd, 2, sd) > 0])
#met19ns.cd <- met19[plot.id, ]
met19.cd <- scale(met19[plot.id, ])
```

2020
```{r, message =F}
var.id <- rownames(psc20)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc20$plot.id
com20.cd <- t(com20[, plot.id])
com20.cd <- scale(com20.cd[, apply(com20.cd, 2, sd) > 0])
#met20ns.cd <- met20[plot.id, ]
met20.cd <- scale(met20[plot.id, ])
```

Integrate + RM
```{r, message =F}
psc <- rbind(psc19,psc20)

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

mrm19.cd <- tcrossprod(com19.cd) / ncol(com19.cd)
mrm20.cd <- tcrossprod(com20.cd) / ncol(com20.cd)

com.cd<- rbind(com19.cd,com20.cd)
rownames(com.cd)<-rownames(psc)
mrm.cd <- tcrossprod(com.cd) / ncol(com.cd)

metrm19.cd <- tcrossprod(met19.cd) / ncol(met19.cd)
metrm20.cd <- tcrossprod(met20.cd) / ncol(met20.cd)

#19<->20
#met.cd<- rbind(met19.cd,met20.cd)
met.cd<- rbind(met20.cd,met19.cd)
rownames(met.cd)<-rownames(psc)
metrm.cd <- tcrossprod(met.cd) / ncol(met.cd)
```






# All DATA


read phenotypic data
```{r}
pheno18 <- read.csv(here("2018", "shoot_blup_all_2018.csv"), row.names = 1)
pheno19 <- read.csv(here("2019", "shoot_blup_all_2019.csv"), row.names = 1)
pheno20 <- read.csv(here("2020", "shoot_blup_all_2020.csv"), row.names = 1)

plot18<-rownames(pheno18)
plot19<-rownames(pheno19)
plot20<-rownames(pheno20)

var18<-pheno18$var.id
var19<-pheno19$var.id
var20<-pheno20$var.id
```

read genomic relationship matrix data
```{r}
grm <- readRDS(here("data", "grm_2.rds"))
head(grm)[,1:3]
```

read metabolomic data
```{r}
met<- read.csv(here("2019","2019_Tottori_Jul_RootMetabolome_X.csv"))
rownames(met) <- paste0(substr(as.matrix(met[7]),1,2),".",sprintf("%03d",as.matrix(met[8])))
met19 <- met[,10:ncol(met)]
colnames(met19)<- sub("M","X",colnames(met19))

met <- read.csv(here("2020", "2020_Tottori_Main_RootMetabolome.csv"))
rownames(met) <- paste0(substr(as.matrix(met[7]),1,2),".",sprintf("%03d",as.matrix(met[8])))
met20 <- met[,10:ncol(met)]

s_c <- colnames(met19) %in% colnames(met20)
met19<- met19[,s_c]
s_c <- colnames(met20) %in% colnames(met19)
met20<- met20[,s_c]
table(colnames(met20) == colnames(met19))

dim(met19)
dim(met20)
```

read predmet
```{r}
predmet20f19 <- read.csv(here("out", "20f19_predmet_GM_blup_OneOut.csv"), row.names = 1)
predmet19f20 <- read.csv(here("out", "19f20_predmet_GM_blup_OneOut.csv"), row.names = 1)


predmet19 <- read.csv(here("out", "19f19_predmet_GM_blup_OneOut.csv"), row.names = 1)
predmet20 <- read.csv(here("out", "20f20_predmet_GM_blup_OneOut.csv"), row.names = 1)
```

read microbiome rarificated data
```{r}
com <- read.table(here("2018", "table-from-biom-7-2018-after.txt"), row.names = 1)
rownames(com) <- gsub(";",".",rownames(com))
com18<- com
colnames(com18) <- cbind(plot18[201:400],plot18[601:800])

com <- read.csv(here("2019", "table-from-biom-7.csv"), row.names = 1)
rownames(com) <- gsub(";",".",rownames(com))
com19<- com

#comriken <- read.csv(here("2020", "table-from-biom-7-2020-after.csv"))
com <- read.csv(here("2020", "2020_Tottori_Main_Microbiome_Ratio.csv"))
rownames(com) <- paste0(substr(as.matrix(com[7]),1,2),".",sprintf("%03d",as.matrix(com[8])))
com <- com[,10:ncol(com)]
com20 <- t(com)

#s_c <- rownames(com19) %in% rownames(com20)
#com19<- com19[s_c,]
#s_c <- rownames(com20) %in% rownames(com19)
#com20<- com20[s_c,]

s_c <- (rownames(com19) %in% rownames(com20)) & (rownames(com19) %in% rownames(com18))
com19<- com19[s_c,]
s_c <- rownames(com20) %in% rownames(com19)
com20<- com20[s_c,]
s_c <- rownames(com18) %in% rownames(com20)
com18<- com18[s_c,]

dim(com18)
dim(com19)
dim(com20)
```


### Drought

```{r}
CD ="W4"
```


select the lines which has pheno, grm, met, micro data in 2019 and 2020
```{r}
selector.grm1 <- pheno18$var.id %in% rownames(grm)
selector.com1 <-rownames(pheno18) %in% colnames(com18)

selector.grm2 <- pheno19$var.id %in% rownames(grm)
selector.com2 <-rownames(pheno19) %in% colnames(com19)

selector.grm3 <- pheno20$var.id %in% rownames(grm)
selector.com3 <-rownames(pheno20) %in% colnames(com20)


pl<- list(pheno18,pheno19,pheno20)
pl.sel<- list()

for (i in 2:3){
pheno<- pl[[i]]

if (i==1) {
  selector.grm <- selector.grm1
  selector.com <- selector.com1
}

else if (i==2) {
  selector.grm <- selector.grm2
  selector.com <- selector.com2
}

else if (i==3) {
  selector.grm <- selector.grm3
  selector.com <- selector.com3
}


pheno.sel <- pheno[selector.grm & selector.com, ]
#head(pheno.sel)
print(dim(pheno.sel))

selector.cd <- substr(rownames(pheno.sel), 1, 2) == CD 
pheno.sel.cd <- pheno.sel[selector.cd, ]
dim(pheno.sel.cd)

plot.id <- rownames(pheno.sel.cd)
rownames(pheno.sel.cd)<-pheno.sel.cd$var.id
pheno.sel.cd$var.id <- plot.id
colnames(pheno.sel.cd)[1]<- "plot.id"
sg <- rownames(grm) %in% rownames(pheno.sel.cd)
gv<-rownames(grm[sg,sg])
pheno.sel.cd<- pheno.sel.cd[gv,]
print(dim(pheno.sel.cd))
pl.sel[[i]]<- pheno.sel.cd
}

#psc18<-  pl.sel[[1]]
psc19<-  pl.sel[[2]] 
psc20<-  pl.sel[[3]]



s_p <- rownames(psc19) %in% rownames(psc20)
psc19<- psc19[s_p,]
s_p <- rownames(psc20) %in% rownames(psc19)
psc20<- psc20[s_p,]

s_p <- colnames(psc19) %in% colnames(psc20)
psc19<- psc19[,s_p]
s_p <- colnames(psc20) %in% colnames(psc19)
psc20<- psc20[,s_p]

table(rownames(psc19) == rownames(psc20))

```



2019 
```{r}
var.id <- rownames(psc19)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc19$plot.id
com19.cd <- t(com19[, plot.id])
com19.cd <- scale(com19.cd[, apply(com19.cd, 2, sd) > 0])
#met19ns.cd <- met19[plot.id, ]
met19.cd <- scale(met19[plot.id, ])
#predmet19ns<-predmet19
predmet19<-scale(predmet19)
```


2020
```{r, message =F}
var.id <- rownames(psc20)
grm.cd <- grm[var.id, var.id]
plot.id  <- psc20$plot.id
com20.cd <- t(com20[, plot.id])
com20.cd <- scale(com20.cd[, apply(com20.cd, 2, sd) > 0])
#met20ns.cd <- met20[plot.id, ]
met20.cd <- scale(met20[plot.id, ])
#predmetns20<-predmet20
predmet20<-scale(predmet20)
#predmetns20f19<-predmet20f19
predmet20f19<-scale(predmet20f19)
predmet19f20<-scale(predmet19f20)
```


Integrate + RM
```{r, message =F}
psc <- rbind(psc19,psc20)

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

s_c <- colnames(com19.cd) %in% colnames(com20.cd)
com19.cd<- com19.cd[,s_c]
s_c <- colnames(com20.cd) %in% colnames(com19.cd)
com20.cd<- com20.cd[,s_c]

mrm19.cd <- tcrossprod(com19.cd) / ncol(com19.cd)
mrm20.cd <- tcrossprod(com20.cd) / ncol(com20.cd)

com.cd<- rbind(com19.cd,com20.cd)
rownames(com.cd)<-rownames(psc)
mrm.cd <- tcrossprod(com.cd) / ncol(com.cd)

metrm19.cd <- tcrossprod(met19.cd) / ncol(met19.cd)
metrm20.cd <- tcrossprod(met20.cd) / ncol(met20.cd)

metPrm19.cd <- tcrossprod(predmet19) / ncol(predmet19)
metPrm20.cd <- tcrossprod(predmet20) / ncol(predmet20)

metPrm20f19.cd <- tcrossprod(predmet20f19) / ncol(predmet20f19)
metPrm19f20.cd <- tcrossprod(predmet19f20) / ncol(predmet19f20)

#metns.cd <- rbind(met19ns.cd,met20ns.cd)
met.cd<- rbind(met19.cd,met20.cd)
rownames(met.cd)<-rownames(psc)
metrm.cd <- tcrossprod(met.cd) / ncol(met.cd)
```

```{R}
comn<-  paste0(rep("OTU_",ncol(com19.cd)),1:ncol(com19.cd))
colnames(com19.cd)<- comn
```

# Full size
```{R}

#x <- com19.cd[1:50,1:50]
#y <- met19.cd[1:50,1:50]

x <- com19.cd
y <- met19.cd

x <- scale(x)
y <- scale(y)

x <- data.frame(x)
y <- data.frame(y)
```


```{R }
# Model the effect of all environmental variables on fish
# community composition
spe.rda <- rda(y ~ ., data = x)
#print(spe.rda)
#summary(spe.rda)
RsquareAdj(spe.rda)
```


```{r}
ordiplot(spe.rda, scaling = 2, type = "text")
```

```{}
# Forward selection of variables:
fwd.sel <- ordiR2step(rda(y ~ 1, data = x), # lower model limit (simple!)
               scope = formula(spe.rda), # upper model limit (the "full" model)
               direction = "forward",
               R2scope = TRUE, # can't surpass the "full" model's R2
               pstep = 10,
               trace = FALSE) # change to TRUE to see the selection process!

# Check the new model with forward-selected variables
fwd.sel$call
```


```{r}
MML.Y <- spe.rda$Ybar
Eigen <- spe.rda$CCA$eig
barplot(Eigen)
RDA_M<- spe.rda$CCA$u[,1:3]

RDA_M <- scale(RDA_M)
RDA_M<-  tcrossprod(RDA_M) / ncol(RDA_M)
```

# Ridge Regression - mono

```{r}

for (i in 1:10) {
  
dia.lm <- lm(y[,i]~.,data=x)
summary(dia.lm)

dia.ridge <- glmnet(x, y[,i], 
                    # family="gaussian", 
                    alpha=0)
#plot(dia.ridge, label=TRUE)
#plot(dia.ridge, xvar="lambda", label=TRUE)
dia.ridge.cv <- cv.glmnet(as.matrix(x), y[,i], 
                          # family="gaussian", 
                          nfolds=nrow(x),
                          alpha=0)
plot(dia.ridge.cv)

#plot(dia.ridge, xvar="lambda", label=TRUE)
#abline(v=log(dia.ridge.cv$lambda.min), lty=2)
}

```

```{r}

tic()
CVRmatrix <- matrix(NA,3,ncol(y))
PARmatrix <- matrix(NA,ncol(x),ncol(y))
PREmatrix <- matrix(NA,nrow(y),ncol(y))
PREmatrix2<- matrix(NA,nrow(y),ncol(y))
rownames(CVRmatrix)<- c("ErrorMin","lambda","loglambda")
rownames(PARmatrix)<- colnames(x)
colnames(PARmatrix)<- colnames(y)
rownames(PREmatrix)<- rownames(y)
colnames(PREmatrix)<- colnames(y)
rownames(PREmatrix2)<- rownames(y)
colnames(PREmatrix2)<- colnames(y)

#for (i in 1:10){
for (i in 1:ncol(y)){

dia.lm <- lm(y[,i]~.,data=x)
summary(dia.lm)


#dia.ridge <- glmnet(x, y[,i], 
                    # family="gaussian", 
                    #alpha=0)
#plot(dia.ridge, label=TRUE)
#plot(dia.ridge, xvar="lambda", label=TRUE)
dia.ridge.cv <- cv.glmnet(as.matrix(x), y[,i], 
                          # family="gaussian", 
                          #nfolds=10,
                          alpha=0)
#plot(dia.ridge.cv)

CVRmatrix[1,i]<-min(dia.ridge.cv$cvm)
CVRmatrix[2,i]<-dia.ridge.cv$lambda.1se
CVRmatrix[3,i]<-log(dia.ridge.cv$lambda.1se)
PARmatrix[,i] <-coef(dia.ridge.cv, s="lambda.1se")[2:nrow(coef(dia.ridge.cv, s="lambda.min"))]
PREmatrix[,i]<-predict(dia.ridge.cv, s="lambda.1se", newx=as.matrix(x))
PREmatrix2[,i]<-predict(dia.ridge.cv, s="lambda.1se", newx=as.matrix(com20.cd))
#plot(dia.ridge, xvar="lambda", label=TRUE)
#abline(v=log(dia.ridge.cv$lambda.min), lty=2)

}

toc()

```
csv
```{R,fig.dim = c(5,3)}
write.csv(PREmatrix,here("out","19f19_Ridge.csv"))
write.csv(PREmatrix2,here("out","20f19_Ridge.csv"))
```

# histall
```{R}
getwd()
myvector <- c(
  "19f20_predmet_G_blup_OneOut.csv",
  "19f20_predmet_M_blup_OneOut.csv",
  "19f20_predmet_GM_blup_OneOut.csv",
  "19f19_predmet_G_blup_OneOut.csv",
  "19f19_predmet_M_blup_OneOut.csv",
  "19f19_predmet_GM_blup_OneOut.csv",
  "19f19_Ridge.csv"
)
sapply(myvector,met19.cd, FUN = histfunction)

```
### hist all
```{R}

myvector <- c(
  "20f19_predmet_G_blup_OneOut.csv",
  "20f19_predmet_GM_blup_OneOut.csv",
  "20f20_predmet_GM_blup_OneOut.csv",
  "20f19_Ridge.csv"
)
sapply(myvector,met20.cd, FUN = histfunction)

```

# PCA



###Yield 2019model

seed
```{r, message =F, include=FALSE}
# save or read the seed
seedIndCsv <-  here("out","seedInd.csv")
if (file.exists(seedIndCsv)) {
  seedInd <- read.csv(seedIndCsv, row.names = 1, header = T)
  seedInd <- c(as.matrix(seedInd))
} else {
  seedInd <- sample(1:500, 10, replace = F)
  write.csv(x = seedInd, file =  here("out","seedInd.csv"))
}
```

```{r, message =F, include=TRUE,eval=TRUE}
K1 <- grm.cd
K2 <- mrm19.cd
K3 <- metrm19.cd
K8 <- metPrm19.cd
K10 <- RDA_M

Z <- design.Z(pheno.labels = rownames(grm.cd),geno.names = rownames(grm.cd))

KZ1<- list(A= list(K = K1, Z = Z))
KZ2<- list(A= list(K = K2, Z = Z))
KZ3<- list(A= list(K = K3, Z = Z))
KZ8<- list(A= list(K = K8, Z = Z))
KZ10<- list(A= list(K = K10, Z = Z))

ZETAlist <- list(KZ1,KZ2,KZ3,KZ8,KZ10)
names(ZETAlist) <- c("KZ1","KZ2","KZ3","KZ8","KZ10")
names<- names(ZETAlist)

```


ModelRun
```{R, message =F, include=TRUE,eval=TRUE}
y <- psc19

resultModelname <- names(ZETAlist)

doFuture::registerDoFuture()
plan("multisession", workers = 10)

xr <- foreach(zl = ZETAlist) %dopar% {
#xr <- foreach(zl = ZETAlist) %dopar% {
  #for (zl in ZETAlist){
  #for (zl in ZETAlist[1]){
  zname = names(zl)
  print(zname)
  
  var.pheno.all = c() #traitごと結果(要約)
  
  ZETA <- zl
  X0 <- NULL
  
  for (i in 2:ncol(y)){
  #for (i in 2){  
    trait.name <- colnames(y)[i]
    print(c(i,"/",ncol(y)))
    print(trait.name)
    # make the case for the result
    
    resultIndex <- c("Correlation", "R2", "RMSE","varU","varE","h2")
    resultEachSeed <- matrix(NA, ncol = length(resultIndex), nrow = length(seedInd))
    colnames(resultEachSeed) <- resultIndex
    rownames(resultEachSeed) <- seedInd
    
    predictionDataRAINBOW <- rep(NA, nrow(y))
    
    for (t in 1:nrow(y)) { 
    #for (t in 1:3) {
      yNa <- y[,i]
      yNa[t] <- NA
      # RAINBOWR
      resEM3 <- EM3.cpp(y = yNa,
                        X0 = X0, n.core = 1, 
                        ZETA = ZETA)
      # input the predicted data
      predictionDataRAINBOW[t] <- resEM3$y.pred[t]
    }
    
    # resEM3$weights
    predictData <- (predictionDataRAINBOW)
    obsData <- (y[,i])
    
    # calculate the R2 and RMSE
    correlation <- cor(obsData, predictData)
    R2 <- 1 - sum((obsData - predictData) ^ 2) / sum((obsData - mean(obsData)) ^ 2)
    RMSE <- sqrt(sum((obsData - predictData) ^ 2) / length(obsData))
    VU <- resEM3$Vu
    VE <- resEM3$Ve
    h2 <-  VU/(VU+VE)
    
    resultsum<- c(correlation, R2, RMSE,VU,VE,h2)
    resultsum<- as.matrix(resultsum)
    colnames(resultsum) <-trait.name
       var.pheno.all <- cbind(var.pheno.all,resultsum)
  }
  
  rownames(var.pheno.all) <- resultIndex
  print(var.pheno.all)
  var.pheno.all
}


resultModelname <- names(ZETAlist)
resultEachModel <- matrix(NA, nrow = length(ZETAlist), ncol = ncol(y)-1)
rownames(resultEachModel) <- names(ZETAlist)
colnames(resultEachModel) <- colnames(y)[2:ncol(y)]

#index p generator
for (n in 1:length(names)){
  
  resultEachModel[n,]<- xr[[n]][1,]
  
  if (n == 1){
    p <- names[1]
  }
  else{
    p  <- paste(p,names[n],sep="")
  }
}
print(p)


names(xr) <- names
resultEachModel_all<- xr


```

csv
```{R,eval=TRUE}
write.csv(resultEachModel, here("out",paste0("2019_blup",p,"_OneOut.csv" )))

write.csv(resultEachModel_all, here("out",paste0("2019_blup_ResAll_",p,"_OneOut.csv" )))
```


result plot
```{R,fig.dim = c(8, 4)}

#pred.all<-resultEachModel
pred.all <- read.csv(here("out",paste0("2019_blup",p,"_OneOut.csv" )),row.names=1)

model.name <- c("G", "Micro","TrueMet","PredMet_f19","RDA_Met")
trait.name <- colnames(pred.all)
df.all <- NULL

for(i in 1:length(trait.name)) {
  
  pred <-  pred.all[,i]
  df <- data.frame(trait = trait.name[i],model = model.name, mean = pred)
  df.all <- rbind(df.all, df)
}


df.all[df.all < 0] <- 0
df.all$model <- factor(df.all$model, levels = model.name)
df.all$trait <- factor(df.all$trait)
levels(df.all$trait) <- colnames(pred.all)
g <- ggplot(df.all)
g <- g + geom_bar(aes(x = trait, y = mean, fill = model), 
                  stat = "identity",  position = "dodge")  + ggtitle("Yield Prediction in 2019")
print(g)
```

```{r}

```



# multivariate Ridge (to reduce the time)

```{r}

#https://search.r-project.org/CRAN/refmans/VARshrink/html/lm_multiv_ridge.html
#lm_multiv_ridge {VARshrink}

multivariate_ridge <- function(X, Y, lambda = 1.0) {
  # X: Matrix of explanatory variables
  # Y: Matrix of response variables
  # lambda: Regularization parameter
  
  # Get dimensions of the matrices
  n <- nrow(X)
  p <- ncol(X)
  m <- ncol(Y)

  # Calculate coefficients for ridge regression
  ridge_coef <- solve(t(X) %*% X + lambda * diag(p), t(X) %*% Y)

  return(list(coefficients = ridge_coef, predictions = predictions))
}

# Example usage
# X: Matrix of explanatory variables
# Y: Matrix of response variables
# lambda: Regularization parameter
# ridge_coef <- multivariate_ridge(X, Y, lambda = 0.1)


multivariate_ridge_vector <- function(X, Y, lambda = rep(1.0, ncol(X))) {
  # X: Matrix of explanatory variables
  # Y: Matrix of response variables
  # lambda: Regularization parameter (vector)
  
  # Get dimensions of the matrices
  n <- nrow(X)
  p <- ncol(X)
  m <- ncol(Y)
  
  # Standardize the explanatory variables
  X <- scale(X, center = TRUE, scale = FALSE)
  
  # Convert the lambda vector to a diagonal matrix
  lambda_matrix <- diag(lambda)
  
  # Calculate coefficients for ridge regression
  ridge_coef <- solve(t(X) %*% X + lambda_matrix, t(X) %*% Y)
  
  return(ridge_coef)
}

# Example usage
# X: Matrix of explanatory variables
# Y: Matrix of response variables
# lambda: Regularization parameter (vector)
# ridge_coef <- multivariate_ridge(X, Y, lambda = c(0.1, 0.01, 0.001))

```



# multivariate Ridge cv (to reduce the time)

```{r}
multivariate_ridge_cv <- function(X, Y, lambda_seq = 10^seq(-3, 3, by = 0.1), nfolds = 5) {
  # X: Matrix of explanatory variables
  # Y: Matrix of response variables
  # lambda_seq: 正則化パラメータの候補のシーケンス
  # nfolds: 交差検証のフォールド数
  
  # Get dimensions of the matrices
  n <- nrow(X)
  p <- ncol(X)
  m <- ncol(Y)
  
  # Standardize the explanatory variables
  X <- scale(X, center = TRUE, scale = FALSE)
  
  # Number of observations
  n <- nrow(X)
  
  # Split the data into k folds
  indices <- sample(1:nfolds, n, replace = TRUE)
  
  # Initialize vectors to store cross-validated errors
  cv_errors <- numeric(length(lambda_seq))
  
  for (i in seq_along(lambda_seq)) {
    lambda <- lambda_seq[i]
    
    # Initialize vector to store cross-validated predictions
    cv_predictions <- matrix(0, n, m)
    
    # Perform cross-validation
    for (fold in 1:nfolds) {
      # Split the data into training and validation sets
      train_indices <- which(indices != fold)
      valid_indices <- which(indices == fold)
      
      # Train the model on the training set
      ridge_coef <- solve(t(X[train_indices, , drop = FALSE]) %*% X[train_indices, , drop = FALSE] + lambda * diag(p),
                          t(X[train_indices, , drop = FALSE]) %*% Y[train_indices, , drop = FALSE])
      
    
    
    # Calculate cross-validated error for the current lambda
    cv_errors[i] <- mean((Y - cv_predictions)^2)
  }
  
  # Find the index of the minimum cross-validated error
  optimal_lambda_index <- which.min(cv_errors)
  optimal_lambda <- lambda_seq[optimal_lambda_index]
  
  # Train the final model with the optimal lambda
  final_ridge_coef <- solve(t(X) %*% X + optimal_lambda * diag(p), t(X) %*% Y)
  
  return(list(optimal_lambda = optimal_lambda, final_ridge_coef = final_ridge_coef))
}

  
# Example usage
# X: Matrix of explanatory variables
# Y: Matrix of response variables
# lambda_seq: 正則化パラメータの候補のシーケンス
# nfolds: 交差検証のフォールド数
# result <- multivariate_ridge_cv(X, Y, lambda_seq = 10^seq(-3, 3, by = 0.1), nfolds = 5)
# optimal_lambda <- result$optimal_lambda
# final_ridge_coef <- result$final_ridge_coef
```






#sRDA
```{R,eval=TRUE}

```

