
SHAP interaction

```{r}
require(here)
require(ranger)
library(igraph)
library(ggraph)
library(dplyr)
library(reticulate)
library(tidyverse)
```

```{r}
cd = "Drought"

if (cd == "Drought"){
	CD<-"W4"
	Data<-readRDS(here("data/SoyData_Drought2.RDS"))
	imp_total<-readRDS(here("out","imp_RF2_d.RDS"))
} else if (cd=="Control"){
	CD<-"W1"
	Data<-readRDS(here("data/SoyData_Control2.RDS"))
	imp_total<-readRDS(here("out","imp_RF2_c.RDS"))
} else {
	stop()
}
	
genome<-Data$genome
grm.cd<-Data$grm
met.cd<-Data$met
mic.cd<-Data$mic
#mir.cd<-Data$mir
psc19<-Data$pheno
microname<-Data$microname
metname<-Data$metname
cd<-Data$cd

genome<- scale(genome)
met.cd<-scale(met.cd)
mic.cd <- scale(mic.cd)
psc19 <- scale(psc19)

dim(genome)
dim(mic.cd)
dim(met.cd)

dim(imp_total)

mm<-matrix(metname,length(metname),1)
rownames(mm)<-  paste0("X", 1:length(metname))

cm<-matrix(microname,length(microname),1)
rownames(cm)<-  paste0("B", 1:length(microname))

#write.csv(mm,here("out","met_list.csv"))
#write.csv(cm,here("out","micro_list.csv"))

```


```{r}

#ic<-cor(imp_total)

imp_sm<-imp_total[, colSums(imp_total) >= 0.01]

# imp.g <- imp_total[, 1:3078]
# imp.m <- imp_total[, 3079:7849]
# imp.met <- imp_total[, 7850:8102]


imp.g <- imp_total[, 1:ncol(genome)]
imp.m <- imp_total[, (ncol(genome)+1):(ncol(genome)+ncol(mic.cd))]
imp.met <- imp_total[, (ncol(genome)+ncol(mic.cd)+1):ncol(imp_total)]

dim(imp.g)
dim(imp.m)
dim(imp.met)

# imp.g <- imp.norm[, 1:ncol(genome)]
# imp.m <- imp.norm[, (ncol(genome)+1):(ncol(genome)+ncol(mic.cd))]
# imp.met <- imp.norm[, (ncol(genome)+ncol(mic.cd)+1):ncol(imp.norm)]


g<-genome[, colSums(imp.g) >= 0.001]
m<-mic.cd[, colSums(imp.m) >= 0.001]
met<-met.cd[, colSums(imp.met) >= 0.001]

im001<-cbind(g,m,met)
dim(im001)


g01<-genome[, colSums(imp.g) >= 0.01]
m01<-mic.cd[, colSums(imp.m) >= 0.01]
met01<-met.cd[, colSums(imp.met) >= 0.02]

dim(g01)
dim(m01)
dim(met01)

data<-cbind(g01,m01,met01,psc19)
im01<-cbind(g01,m01,met01)
dim(data)


data <- data.frame(data)



# Convert to be usable in Python
assign("im001", im001, envir = .GlobalEnv)
assign("im01", im01, envir = .GlobalEnv)
assign("psc19", psc19, envir = .GlobalEnv)

```


```{python,eval=F}
import shap
import numpy as np
import pandas as pd
import xgboost
import matplotlib.pyplot as plt
import random
```


```{python,eval=F}
# Create data
X = r.im001
Y = r.psc19[:, 0]

print(X.shape)
print(Y.shape)

```


```{python,eval=F}
# Build model
seed =123
np.random.seed(seed)
random.seed(seed)

model = xgboost.XGBRegressor(n_estimators=100, random_state=seed)
model.fit(X, Y)

# Calculate SHAP
explainer = shap.TreeExplainer(model)
shap_interaction_values = explainer.shap_interaction_values(X)

# Interaction matrix
interaction_matrix = pd.DataFrame(shap_interaction_values.mean(axis=0))

interaction_matrix
```


```{python,eval=F}

# If interaction_matrix is a DataFrame, flatten all values and draw a histogram
interaction_matrix_values = interaction_matrix.values.flatten()

# Plot histogram
plt.hist(interaction_matrix_values, bins=30, edgecolor='black')
plt.title('Histogram of SHAP Interaction Values')
plt.xlabel('SHAP Interaction Value')
plt.ylabel('Frequency')
plt.show()

import reticulate

interaction_matrix_r = r.interaction_matrix = interaction_matrix
```


```{r,eval=F}

# Pass Python variables to R
imr <- py$interaction_matrix
imr <- as.matrix(imr)
hist(imr)
max(imr)
dim(imr)

colnames(imr)<-colnames(im001)
rownames(imr)<-colnames(im001)


if (cd == "Drought"){
	saveRDS(imr,here("out","imr_d3"))
} else if (cd=="Control"){
	saveRDS(imr,here("out","imr_c3"))
} else {
	stop()
}
```


```{r}
if (cd == "Drought"){
	imr<- readRDS(here("out","imr_d3"))
} else if (cd=="Control"){
	imr<- readRDS(here("out","imr_c2"))
} else {
	stop()
}

# Remove constant columns (zero variance)
imr_filtered <- imr[, apply(imr, 2, function(x) sd(x) != 0)]

# Also remove corresponding rows (assuming a square matrix)
imr_filtered <- imr_filtered[apply(imr_filtered, 1, function(x) sd(x) != 0), ]

heatmap(imr_filtered)
```


```{r}
set.seed(123)
#cd = "Control"

if (cd == "Drought"){
	imr<- readRDS(here("out","imr_d3"))
} else if (cd=="Control"){
	imr<- readRDS(here("out","imr_c2"))
} else {
	stop()
}

# Transform to log scale
imr_l <- log10(imr+1)/2

hist(imr_l)

# Set negative values to zero
imr_l[imr_l < 0] <- 0

# Count positive values in each column
positive_counts <- apply(imr_l, 2, function(x) sum(x > 0))

# Display the result vector
print(positive_counts)

# 1. Create edge list from interaction matrix where values exceed threshold
threshold <- 5e-05
edges <- which(imr_l > threshold, arr.ind = TRUE)

edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. Create node information
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# Classify nodes based on feature name patterns
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

# Define node colors
node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "orange",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 3. Create igraph object
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 4. Remove nodes with degree less than 3
node_degree <- degree(g)
g <- delete_vertices(g, V(g)[node_degree < 3])

# 5. Get degree of remaining nodes and set as attributes
V(g)$degree <- degree(g)

# Set node size based on degree
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)

# Convert node size to factor for legend
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 6. Draw the graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = name), repel = TRUE) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
	guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
  theme_void() +
  theme(legend.position = "right")

print(degree(g))


```
 [1] 10 18 28  4 14  8  2  2  8  4  4 10  4  4  4  6  6 14  4  4  6
[22]  4  8  2  0  4  2  4  4  6  6  2  6  6  4  6  4  6  6  4  4  4
[43]  6  4  4  6  4  2  6  4  4  6  6  4


# super subset
```{r}
if (cd == "Drought"){
	target_nodes <- c("X235", "X53")
	#target_nodes <- c("X235", "X53","X45","X75")
} else if (cd=="Control"){
	target_nodes <- c("X35", "X98", "X190", "Chr4_22035062")
} else {
	stop()
}

# 1. Create edge list from interaction matrix (threshold exceeded)
threshold <- 5e-05
edges <- which(imr_l > threshold, arr.ind = TRUE)
edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. Filter only rows containing target nodes
edges_df <- edges_df %>% 
  filter(from %in% target_nodes | to %in% target_nodes)

# 3. Create node information
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 4. Assign node types
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "orange",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 5. Create subgraph
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 6. Set node degree and size
V(g)$degree <- degree(g)
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 7. Draw graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = name), repel = TRUE) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
  guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
  theme_void() +
  theme(legend.position = "right")


```

```{r}
# Additional: Function to extract family from microbiome string
extract_family <- function(tax_str) {
  family_match <- regmatches(tax_str, regexpr("f__[^;]+", tax_str))
  ifelse(length(family_match) > 0, gsub("f__", "", family_match), NA)
}

if (cd == "Drought"){
	#target_nodes <- c("X235", "X53")
	target_nodes <- c("X235", "X53","X45","X75")
} else if (cd=="Control"){
	target_nodes <- c("X35", "X98", "X190", "Chr4_22035062")
} else {
	stop()
}

# 1. Create edge list from interaction matrix (threshold exceeded)
threshold <- 5e-05
edges <- which(imr_l > threshold, arr.ind = TRUE)
edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. Filter only rows containing target nodes
edges_df <- edges_df %>% 
  filter(from %in% target_nodes | to %in% target_nodes)

# 3. Create node information
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 4. Assign node types
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

# 5. Generate labels for display
micro_labels <- sapply(cm, extract_family)
nodes <- nodes %>%
  mutate(
    label = case_when(
      grepl("^X", name) ~ mm[as.numeric(gsub("X", "", name))],
      grepl("^B", name) ~ micro_labels[as.numeric(gsub("B", "", name))],
      TRUE ~ name
    )
  )

# 6. Define colors for visualization
node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "orange",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 7. Create subgraph
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 8. Set node degree and size
V(g)$degree <- degree(g)
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 9. Draw graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = label), repel = TRUE) +  # ← using label
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
  guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
  ggtitle(paste("Condition:", cd)) +
  theme_void() +
  theme(legend.position = "right")

# 10. Create correspondence table (sort left side alphabetically)
edge_pairs <- edges_df %>%
  filter(from %in% target_nodes | to %in% target_nodes) %>%
  mutate(
    target_node = ifelse(from %in% target_nodes, from, to),
    partner_node = ifelse(from %in% target_nodes, to, from)
  ) %>%
  select(target_node, partner_node, weight) %>%
  arrange(target_node, partner_node)

# 11. Write CSV file

# Merge with labels
edge_pairs <- edge_pairs %>%
  left_join(nodes[, c("name", "label")], by = c("target_node" = "name")) %>%
  rename(target_label = label) %>%
  left_join(nodes[, c("name", "label")], by = c("partner_node" = "name")) %>%
  rename(partner_label = label)

# Sort before CSV output (by label)
edge_pairs <- edge_pairs %>%
  arrange(target_label, partner_label)

#write.csv(edge_pairs, file = paste0("target_node_links_", cd, ".csv"), row.names = FALSE)

```


others check
```{r}
# others check
target_nodes <- c("X235", "X53","X45","X75")
#target_nodes <- c("X35", "X98", "X190", "Chr4_22035062")
cd="Drought"
set.seed(123)
if (cd == "Drought"){
	imr<- readRDS(here("out","imr_d3"))
} else if (cd=="Control"){
	imr<- readRDS(here("out","imr_c2"))
} else {
	stop()
}

imr_l<-log10(imr+1)/2

hist(imr_l)

imr_l[imr_l < 0] <- 0

# 4. Count number of positive values in each column
positive_counts <- apply(imr_l, 2, function(x) sum(x > 0))

# 5. Display the result as a vector
print(positive_counts)

# 1. Create edge list from interaction matrix (above threshold)
threshold <- 0
edges <- which(imr_l > threshold, arr.ind = TRUE)
edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. Filter rows to include only those with target nodes
edges_df <- edges_df %>% 
  filter(from %in% target_nodes | to %in% target_nodes)

# 3. Create node information
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 4. Assign node types
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "orange",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 5. Create subgraph
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 6. Set node degree and size
V(g)$degree <- degree(g)
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 7. Draw graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = name), repel = TRUE) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
  guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
  theme_void() +
  theme(legend.position = "right")

```


```{r}
target_nodes <- c("X235", "X53","X45","X75")
#target_nodes <- c("X35", "X98", "X190", "Chr4_22035062")
cd="Drought"
set.seed(123)
if (cd == "Drought"){
	imr<- readRDS(here("out","imr_d3"))
} else if (cd=="Control"){
	imr<- readRDS(here("out","imr_c2"))
} else {
	stop()
}

imr_l<-log10(imr+1)/2

hist(imr_l)

imr_l[imr_l < 0] <- 0

# 4. Count number of positive values in each column
positive_counts <- apply(imr_l, 2, function(x) sum(x > 0))

# 5. Display the result as a vector
print(positive_counts)

# 1. Create edge list from interaction matrix (above threshold)
threshold <- 5e-05
edges <- which(imr_l > threshold, arr.ind = TRUE)
edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. Filter rows to include only those with target nodes
edges_df <- edges_df %>% 
  filter(from %in% target_nodes | to %in% target_nodes)

# 3. Create node information
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 4. Assign node types
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "orange",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 5. Create subgraph
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 6. Set node degree and size
V(g)$degree <- degree(g)
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 7. Draw graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = name), repel = TRUE) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
  guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
  theme_void() +
  theme(legend.position = "right")

```




```{r}
target_nodes <- c("X235", "X53","X45","X75")
#target_nodes <- c("X35", "X98", "X190", "Chr4_22035062")
cd="Drought"
set.seed(123)
if (cd == "Drought"){
	imr<- readRDS(here("out","imr_d3"))
} else if (cd=="Control"){
	imr<- readRDS(here("out","imr_c2"))
} else {
	stop()
}

imr_l<-log10(imr+1)/2

hist(imr_l)

imr_l[imr_l < 0] <- 0

# 4. Count number of positive values in each column
positive_counts <- apply(imr_l, 2, function(x) sum(x > 0))

# 5. Display the result as a vector
print(positive_counts)

# 1. Create edge list from interaction matrix (above threshold)
threshold <- 5e-05
edges <- which(imr_l > threshold, arr.ind = TRUE)
edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. Filter rows to include only those with target nodes
edges_df <- edges_df %>% 
  filter(from %in% target_nodes | to %in% target_nodes)

# 3. Create node information
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 4. Assign node types
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "orange",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 5. Create subgraph
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 6. Set node degree and size
V(g)$degree <- degree(g)
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 7. Draw graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = name), repel = TRUE) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
  guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
  theme_void() +
  theme(legend.position = "right")

# 8. node size
V(g)$degree <- degree(g)
V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
  V(g)$degree > 20 ~ 12
)
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# 9. graph
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +
  geom_node_text(aes(label = label), repel = TRUE) +  # ← label 使用
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
  guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"), override.aes = list(color = "gray"))) +
	  ggtitle(paste("Condition:", cd)) +
  theme_void() +
  theme(legend.position = "right")




# 10. compare
edge_pairs <- edges_df %>%
  filter(from %in% target_nodes | to %in% target_nodes) %>%
  mutate(
    target_node = ifelse(from %in% target_nodes, from, to),
    partner_node = ifelse(from %in% target_nodes, to, from)
  ) %>%
  select(target_node, partner_node, weight) %>%
  arrange(target_node, partner_node)

# 11. CSV 

# label
edge_pairs <- edge_pairs %>%
  left_join(nodes[, c("name", "label")], by = c("target_node" = "name")) %>%
  rename(target_label = label) %>%
  left_join(nodes[, c("name", "label")], by = c("partner_node" = "name")) %>%
  rename(partner_label = label)

# csv
edge_pairs <- edge_pairs %>%
  arrange(target_label, partner_label)

#write.csv(edge_pairs, file = paste0("target_node_links4_", cd, ".csv"), row.names = FALSE)

```