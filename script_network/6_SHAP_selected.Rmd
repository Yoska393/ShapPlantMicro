---
title: "6_SHAP_selected"
author: "Hayato Yoshioka"
date: "2025-04-30"
output: html_document
---

for making table

```{r}
library(dplyr)
library(here)
library(VennDiagram)
library(xtable)

library(grid)

```



```{r}
cd = "Control"

if (cd == "Drought"){
	CD<-"W4"
	csv_path <- paste0("target_node_links4_", cd, ".csv")
edge_pairs <- read.csv(csv_path, stringsAsFactors = FALSE)
} else if (cd=="Control"){
	CD<-"W1"
	csv_path <- paste0("target_node_links_", cd, ".csv")
  edge_pairs <- read.csv(csv_path, stringsAsFactors = FALSE)
} else {
	stop()
}
```


```{r}
extract_genus <- function(tax_str) {
  family_match <- regmatches(tax_str, regexpr("g__[^;]+", tax_str))
  ifelse(length(family_match) > 0, gsub("g__", "", family_match), NA)
}

```

```{r}

# 1. 無向エッジの重複を除去（アルファベット順に統一）
edge_pairs_unique <- edge_pairs %>%
  mutate(
    node_a = pmin(target_label, partner_label),
    node_b = pmax(target_label, partner_label)
  ) %>%
  distinct(node_a, node_b, .keep_all = TRUE)

edge_pairs_unique <- edge_pairs_unique %>%
  mutate(
    node_a = substr(node_a, 1, 40),
    node_b = substr(node_b, 1, 40),
    log_weight = log(weight)
  ) %>%
  arrange(desc(log_weight))

get_label <- function(name) {
  case_when(
    grepl("^X", name) ~ mm[as.numeric(gsub("X", "", name))],
    grepl("^B", name) ~ micro_labels_genus[as.numeric(gsub("B", "", name))],
    TRUE ~ name
  )
}
edge_pairs_unique <- edge_pairs_unique %>%
  mutate(
    label_a = sapply(target_node, get_label),
    label_b = sapply(partner_node, get_label)
  )

 micro_labels_genus <- sapply(cm, extract_genus)
# grepl("^X", name) ~ mm[as.numeric(gsub("X", "", name))]
# grepl("^B", name) ~ micro_labels_genus[as.numeric(gsub("B", "", name))],


xt <- xtable(
  edge_pairs_unique[, c("label_a", "label_b","log_weight","target_node","partner_node")],
  digits = c(0, 0, 0, 2,0,0),
  caption = paste("Top interactions in", cd, "condition (log(weight))"),
  label = paste0("tab:log_interactions_", tolower(cd))
)



# 4. 出力（行番号なし）
print(xt, include.rownames = FALSE)

```

```{r}

if (cd == "Drought"){
	CD<-"W4"
priority_nodes <- c("Daidzin", "L-Ornithine monohydrochloride")
priority_nodes <- c("Daidzin", "L-Ornithine monohydrochloride","L-Asparagine","gamma-Amino-n-butyric acid")
} else if (cd=="Control"){
	CD<-"W1"
priority_nodes <- c("Daidzin", "L-Ornithine monohydrochloride")

} else {
	stop()
}


# 1. 優先ノードを定義（左側に配置したいノード）

# 2. 無向エッジの重複を除去（優先ノードを node_a に配置）
edge_pairs_unique <- edge_pairs %>%
  mutate(
    node_a = case_when(
      target_label %in% priority_nodes ~ target_label,
      partner_label %in% priority_nodes ~ partner_label,
      TRUE ~ pmin(target_label, partner_label)
    ),
    node_b = case_when(
      node_a == target_label ~ partner_label,
      node_a == partner_label ~ target_label,
      TRUE ~ pmax(target_label, partner_label)
    )
  ) %>%
  distinct(node_a, node_b, .keep_all = TRUE) %>%
  mutate(
    node_a = substr(node_a, 1, 40),
    node_b = substr(node_b, 1, 40),
    log_weight = log(weight)
  ) %>%
  arrange(desc(log_weight))


get_label <- function(name) {
  case_when(
    grepl("^X", name) ~ mm[as.numeric(gsub("X", "", name))],
    grepl("^B", name) ~ micro_labels_genus[as.numeric(gsub("B", "", name))],
    TRUE ~ name
  )
}
edge_pairs_unique <- edge_pairs_unique %>%
  mutate(
    label_a = sapply(target_node, get_label),
    label_b = sapply(partner_node, get_label),
    label_a = substr(label_a, 1, 40),
    label_b = substr(label_b, 1, 40)
  )


# 3. xtable に変換（log_weight付き）
xt <- xtable(
  edge_pairs_unique[, c("target_node","partner_node","label_a", "label_b", "log_weight")],
  digits = c(0, 0, 0,0,0, 3),
  caption = paste("Top interactions in", cd, "condition (log(weight))"),
  label = paste0("tab:log_interactions_", tolower(cd))
)

# 4. 表を出力（行番号なし）
print(xt, include.rownames = FALSE)

```

```{}
rhodano_hits <- grep("Rhodano", microname, value = TRUE)
rhodano_hits 
```


all metabo
```{r}
set.seed(123)
cd <- "Drought"
nodes <- read.csv(paste0("nodes_all_", cd, ".csv"))

# Metabolome かつ名前が "X" で始まるものを抽出
metabolome_nodes <- subset(nodes, type == "Metabolome")

# 数字の部分を抽出して並べ替え用に変換
metabolome_nodes$index <- as.numeric(sub("X", "", metabolome_nodes$name))

# Xの番号順に並べ替え
metabolome_nodes_sorted <- metabolome_nodes[order(metabolome_nodes$index), ]

mm_sorted <- mm[metabolome_nodes_sorted$index]

mm_sorted<-substr(mm_sorted, 1, 40)

metabolome_nodes_sorted$fullname <- mm_sorted


print(metabolome_nodes_sorted)

# name と fullname の列だけを抽出
slist <- metabolome_nodes_sorted[, c("name", "fullname")]

# xtable で整形
xtable_slist <- xtable(slist)

# 結果を表示（または出力）
print(xtable_slist, type = "latex", include.rownames = FALSE)  # LaTeX にしたい場合は type = "latex"
```


```{r}
set.seed(123)

# Control データ読み込みと処理
nodes_control <- read.csv("nodes_all_Control.csv")
metabolome_control <- subset(nodes_control, type == "Metabolome")
metabolome_control$index <- as.numeric(sub("X", "", metabolome_control$name))
control_X <- sort(metabolome_control$index)

# Drought データ読み込みと処理
nodes_drought <- read.csv("nodes_all_Drought.csv")
metabolome_drought <- subset(nodes_drought, type == "Metabolome")
metabolome_drought$index <- as.numeric(sub("X", "", metabolome_drought$name))
drought_X <- sort(metabolome_drought$index)

mm_sorted <- mm[metabolome_nodes_sorted$index]
mm_sorted<-substr(mm_sorted, 1, 40)
metabolome_nodes_sorted$fullname <- mm_sorted


# 比較
only_in_control <- setdiff(control_X, drought_X)
only_in_drought <- setdiff(drought_X, control_X)
in_both <- intersect(control_X, drought_X)

# 結果表示
cat("✅ X番号の比較:\n")
cat("Controlのみ: ", only_in_control, "\n")
cat("Droughtのみ: ", only_in_drought, "\n")
cat("共通: ", in_both, "\n")

# 数を比較
cat("\n✅ 件数の比較:\n")
cat("Control: ", length(control_X), "\n")
cat("Drought: ", length(drought_X), "\n")
cat("共通: ", length(in_both), "\n")

# データの準備（前処理済の index を想定）
control_set <- unique(control_X)   # 例: c(4, 5, 14, 15, 16, 23)
drought_set <- unique(drought_X)   # 同上

# Venn図の描画
venn.plot <- draw.pairwise.venn(
  area1 = length(control_set),
  area2 = length(drought_set),
  cross.area = length(intersect(control_set, drought_set)),
  category = c("Control", "Drought"),
  fill = c("skyblue", "tomato"),
  lty = "blank",  # 線なし
  cex = 1.5,      # 数字サイズ
  cat.cex = 1.5,  # ラベルサイズ
  cat.pos = c(-20, 20),  # ラベル位置調整
  cat.dist = 0.05
)

png("metabolome_venn.png", width = 800, height = 600)
grid.draw(venn.plot)
dev.off()
```


```{r}
library(xtable)

# ---- 読み込みと前処理 ----
nodes_c <- read.csv("nodes_all_Control.csv")
nodes_d <- read.csv("nodes_all_Drought.csv")

# Metabolome 抽出とインデックス処理
met_c <- subset(nodes_c, type == "Metabolome")
met_d <- subset(nodes_d, type == "Metabolome")

met_c$index <- as.numeric(sub("X", "", met_c$name))
met_d$index <- as.numeric(sub("X", "", met_d$name))

# 共通・一方のみのインデックスを抽出
common_idx <- intersect(met_c$index, met_d$index)
only_c_idx <- setdiff(met_c$index, met_d$index)
only_d_idx <- setdiff(met_d$index, met_c$index)

# データ抽出（それぞれ並べ替え）
c_only <- met_c[met_c$index %in% only_c_idx, ]
d_only <- met_d[met_d$index %in% only_d_idx, ]
cd_both <- met_c[met_c$index %in% common_idx, ]  # 片方でOK

# fullname を mm ベクトルから付与（先頭40文字）
c_only$fullname <- substr(mm[c_only$index], 1, 40)
d_only$fullname <- substr(mm[d_only$index], 1, 40)
cd_both$fullname <- substr(mm[cd_both$index], 1, 40)

# 必要列だけ抽出
slist_c <- c_only[, c("name", "fullname")]
slist_d <- d_only[, c("name", "fullname")]
slist_cd <- cd_both[, c("name", "fullname")]

sort_by_xindex <- function(df) {
  df$xindex <- as.numeric(sub("X", "", df$name))  # X番号を数値化
  df <- df[order(df$xindex), ]
  df$xindex <- NULL  # 並び替え用の列を削除
  return(df)
}

# 並べ替え適用
slist_c <- sort_by_xindex(slist_c)
slist_d <- sort_by_xindex(slist_d)
slist_cd <- sort_by_xindex(slist_cd)

# ---- xtable 出力 ----
cat("%% ---- Control Only ----\n")
print(xtable(slist_c), type = "latex", include.rownames = FALSE)

cat("\n%% ---- Drought Only ----\n")
print(xtable(slist_d), type = "latex", include.rownames = FALSE)

cat("\n%% ---- Common to Both (CD) ----\n")
print(xtable(slist_cd), type = "latex", include.rownames = FALSE)

```


