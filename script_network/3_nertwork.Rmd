---
title: "3_network"
author: "Hayato Yoshioka"
date: "2025-03-03"
output: html_document
---


```{r}
require(BGLR)
library(dplyr)
require(here)
require(ggplot2)
require(reshape2)
library(stringr)
library(RAINBOWR)
library(foreach)
library(future)
library(doFuture)
# library(doRNG)
library(tictoc)
library(doSNOW)
library(purrr)
source("Script/MyFunctions.R")

require(ranger)
require(ggrepel)
# require(tidyverse)
library(rrda)
library(bnlearn)
getwd()
library(iml)
library(data.table)
library(ggplot2)
library(igraph)
library(ggraph)
library(tidygraph)
library(xtable)
```

```{r}
cd = "Drought"

if (cd == "Drought"){
	CD<-"W4"
	Data<-readRDS(here("data/SoyData_Drought.RDS"))
} else if (cd=="Control"){
	CD<-"W1"
	Data<-readRDS(here("data/SoyData_Control.RDS"))
}

genome<-Data$genome
grm.cd<-Data$grm
met.cd<-Data$met
mic.cd<-Data$mic
mir.cd<-Data$mir
psc19<-Data$pheno
miname<-Data$microname
metname<-Data$metname
cd<-Data$cd

genome<- scale(genome)
met.cd<-scale(met.cd)
mic.cd <- scale(mic.cd)
psc19 <- scale(psc19)

colnames(met.cd)<-paste0("X",c(1:ncol(met.cd)))

# 
# paste0("X",c(1:ncol(met.cd)))
# metname
# 
# colnames(mic.cd)
# miname




```

```{r}
imp_total<-readRDS(here("out","imp_RF.RDS"))
#ic<-cor(imp_total)

imp_sm<-imp_total[, colSums(imp_total) >= 0.01]

imp.g <- imp_total[, 1:3078]
imp.m <- imp_total[, 3079:7849]
imp.met <- imp_total[, 7850:8102]


g<-genome[, colSums(imp.g) >= 0.001]
m<-mic.cd[, colSums(imp.m) >= 0.001]
met<-met.cd[, colSums(imp.met) >= 0.001]

im001<-cbind(g,m,met)
dim(im001)


g01<-genome[, colSums(imp.g) >= 0.01]
m01<-mic.cd[, colSums(imp.m) >= 0.01]
met01<-met.cd[, colSums(imp.met) >= 0.01]

dim(g01)
dim(m01)
dim(met01)

data<-cbind(g01,m01,met01,psc19)
im01<-cbind(g01,m01,met01)
dim(data)


data <- data.frame(data)

library(reticulate)

# Pythonで使えるように変換
assign("im001", im001, envir = .GlobalEnv)
assign("im01", im01, envir = .GlobalEnv)
assign("psc19", psc19, envir = .GlobalEnv)

```

```{r}
# Extract the column names from imp_total
imp_columns <- colnames(im01)

# Combine the two vectors into a data frame with only columns present in imp_total
df <- data.frame(Column = paste0("X", c(1:ncol(met.cd))), MetName = metname)
df_met <- df[df$Column %in% paste0("X", which(colnames(met.cd) %in% imp_columns)), ]

dim(df_met)


# Filter column names in mic.cd based on imp_columns
filtered_columns <- colnames(mic.cd)[colnames(mic.cd) %in% imp_columns]

# Create a data frame combining the filtered column names from mic.cd and the miname vector
df_micro <- data.frame(Column = filtered_columns, MetName = miname[1:length(filtered_columns)])

dim(df_micro)

```




test of normality
```{r}
par(mfrow = c(2,5), mar = c(4,2,2,2))
for(var in c(1:ncol(data))){
    x = data[ ,var]
    hist(x, prob = TRUE, xlab = var, ylab = "", main = "", col = "ivory")
    lines(density(x), lwd = 2, col = "red")
    curve(dnorm(x, mean = mean(x), sd = sd(x)), from = min(x), to = max(x), add = TRUE, lwd = 2, col = "blue")
}
```
```{}
dag = hc(data, score = "bic-g")
graphviz.plot(dag, shape = "ellipse")
```

nonlinear
```{}
str.diff = boot.strength(data, R = 20, algorithm = "hc", 
												 algorithm.args = list(score="bic-g" 
												 											#,whitelist=wl, 
												 											#blacklist=bl
												 											))
head(str.diff)

```

```{, fig.width = 12, fig.height=6}
attr(str.diff, "threshold")
plot(str.diff)

nrow(str.diff[str.diff$strength > attr(str.diff, "threshold") & str.diff$direction > 0.5, ])
nrow(str.diff[str.diff$strength > 0.6 & str.diff$direction > 0.5, ])
nrow(str.diff[str.diff$strength > 0.7 & str.diff$direction > 0.5, ])

avg.diff = averaged.network(str.diff)
strength.plot(avg.diff, str.diff, shape = "ellipse")

avg.diff = averaged.network(str.diff, threshold = 0.6)
strength.plot(avg.diff, str.diff, shape = "ellipse")
avg.diff = averaged.network(str.diff, threshold = 0.2)
strength.plot(avg.diff, str.diff, shape = "ellipse")

avg.diff = averaged.network(str.diff, threshold = 0.7)
strength.plot(avg.diff, str.diff, shape = "ellipse")

avg.diff = averaged.network(str.diff, threshold = 0.8)
strength.plot(avg.diff, str.diff, shape = "ellipse")

avg.diff = averaged.network(str.diff, threshold = 0.85)
strength.plot(avg.diff, str.diff, shape = "ellipse")
```





# SHAP net

sim
```{r}
set.seed(123)

X<-cbind(g01,m01,met01)

#X<- cbind(genome, mic.cd, met.cd)[,colSums(imp_total) >= 0.015]
Y<- psc19

X <- data.frame(X)
Y <- data.frame(Y)

dim(X)
dim(Y)


# SHAP の結果を保存するリスト
shap_results <- list()

#for (i in 1:ncol(Y)) {
for (i in 1) {
  cat("Processing phenotype:", colnames(Y)[i], "\n")


  imp_vars <- colnames(X)  

 df <- data.frame(X)
 df[[colnames(Y)[i]]] <- Y[[i]]  # 目的変数の列名を正しく設定

# ranger を使ってモデルを再学習
rf_model <- ranger(
  formula = as.formula(paste(colnames(Y)[i], "~ .")),  # 目的変数を明示
  data = df,  # 目的変数の名前を正しく含めたデータ
  num.trees = 100
)

  # iml の Predictor オブジェクトを作成
  predictor <- Predictor$new(rf_model, data=X, y=Y[[i]])

  # SHAP の計算 (サンプルの一部で計算)
  shapley <- Shapley$new(predictor, x.interest=X[1, , drop=FALSE])
  shap_values <- shapley$results

  # 結果をリストに保存
  shap_results[[colnames(Y)[i]]] <- shap_values
}

# SHAP の可視化 (例: 最初の形質に対する SHAP 影響度)
shap_df <- as.data.frame(shap_results[[colnames(Y)[1]]])

# プロット
ggplot(shap_df, aes(x=phi, y=feature.value, color=feature)) +
  geom_point() +
  labs(title=paste("SHAP Values for", colnames(Y)[1]),
       x="SHAP Value",
       y="Feature Value") +
  theme_minimal()

# ggplot(shap_df, aes(x=phi, y=reorder(feature, phi, FUN=median), color=feature_value)) +
#   geom_point(alpha=0.6) +
#   scale_color_gradient(low="blue", high="red") +
#   labs(title=paste("SHAP Summary Plot for", colnames(Y)[1]),
#        x="SHAP Value",
#        y="Feature") +
#   theme_minimal()


```

```{python}
import shap
import numpy as np
import pandas as pd
import xgboost


# データ作成
X = r.im001
Y = r.psc19[:, 0]  # 1列目を取得


print(X.shape)  # Xの行数と列数
print(Y.shape)  # Yの行数と列数


# モデル作成
model = xgboost.XGBRegressor(n_estimators=100)
model.fit(X, Y)

# SHAPの計算
explainer = shap.TreeExplainer(model)
shap_interaction_values = explainer.shap_interaction_values(X)

# 相互作用行列
interaction_matrix = pd.DataFrame(shap_interaction_values.mean(axis=0))

# 結果を表示
interaction_matrix
import matplotlib.pyplot as plt

# interaction_matrixがデータフレームである場合、すべての値をフラットにしてヒストグラムを描画
interaction_matrix_values = interaction_matrix.values.flatten()

# ヒストグラムのプロット
plt.hist(interaction_matrix_values, bins=30, edgecolor='black')
plt.title('Histogram of SHAP Interaction Values')
plt.xlabel('SHAP Interaction Value')
plt.ylabel('Frequency')
plt.show()

import reticulate

interaction_matrix_r = r.interaction_matrix = interaction_matrix
```


```{r}
library(reticulate)

# Pythonの変数をRに渡す
imr <- py$interaction_matrix
imr <- as.matrix(imr)
hist(imr)
max(imr)
dim(imr)

colnames(imr)<-colnames(im001)
rownames(imr)<-colnames(im001)


imr_l<-log10(imr+1)/2

hist(imr_l)

imr_l[imr_l < 0] <- 0

# 4. 各列ごとにプラスの数をカウント
positive_counts <- apply(imr_l, 2, function(x) sum(x > 0))

# 5. 結果をベクトルとして表示
print(positive_counts)

```

```{r}
library(igraph)
library(ggraph)
library(dplyr)

# 1. 相互作用行列からエッジリストを作成
threshold <- 5e-05 # 相互作用がしきい値を超える場合にエッジとして扱う
edges <- which(imr_l > threshold, arr.ind = TRUE)

edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. ノード情報の作成
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 特徴名に基づいてノードのタイプを分類
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",
      grepl("^B", name) ~ "Microbiome",
      grepl("^X", name) ~ "Metabolome",
      grepl("^Dry", name) ~ "Phenotype",
      TRUE ~ "Other"
    )
  )

node_colors <- c("Genome" = "#FF6F61",
                 "Microbiome" = "#66B032",
                 "Metabolome" = "#4B8BBE",
                 "Phenotype" = "#9B4F96",
                 "Other" = "#B0B0B0")

# 3. igraph グラフを作成
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 4. 繋がり（次数）が3未満のノードを除外
node_degree <- degree(g)
g <- delete_vertices(g, V(g)[node_degree < 3])

# 5. 残ったノードの次数を取得し、ノード属性として設定
V(g)$degree <- degree(g)

V(g)$size <- case_when(
  V(g)$degree <= 3 ~ 2,
  V(g)$degree > 3 & V(g)$degree <= 10 ~ 4,
  V(g)$degree > 10 & V(g)$degree <= 20 ~ 8,
    V(g)$degree > 20 ~ 12
)
# ノードサイズをファクターに変換
V(g)$size <- factor(V(g)$size, levels = c(2, 4, 8, 12), labels = c("-3", "-10", "-20", "20+"))

# グラフを描画
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +
  geom_node_point(aes(color = type, size = size)) +  # ここで color と size を指定
  geom_node_text(aes(label = name), repel = TRUE) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual(values = node_colors) +
  scale_size_manual(values = c(2, 4, 8, 12)) + 
	guides(size = guide_legend(title = "Node Size", title.position = "top", 
                             labels = c("-3", "-10", "-20", "20+"),  override.aes = list(color = "gray")))+  # sizeにテキストを表示
  theme_void() +
  theme(legend.position = "right")
```


```{r}
library(igraph)
library(ggraph)
library(dplyr)

# 1. 相互作用行列からエッジリストを作成
# imr_l は 43 x 43 の行列で、相互作用がない場合は 0
threshold <- 3e-05 # 相互作用がしきい値を超える場合にエッジとして扱う
edges <- which(imr_l > threshold, arr.ind = TRUE)

# 'from' と 'to' を行列のインデックスから名前に変換
# imr_l の行名と列名を特徴名として仮定

edges_df <- data.frame(
  from = rownames(imr_l)[edges[, 1]],
  to = colnames(imr_l)[edges[, 2]],
  weight = imr_l[edges]
)

# 2. ノード情報の作成
nodes <- data.frame(name = unique(c(edges_df$from, edges_df$to)))

# 特徴名に基づいてノードのタイプを分類
nodes <- nodes %>%
  mutate(
    type = case_when(
      grepl("^Ch", name) ~ "Genome",  # "Ch" で始まる特徴 -> Genome
      grepl("^B", name) ~ "Microbiome",  # "B" で始まる特徴 -> Microbiome
      grepl("^X", name) ~ "Metabolome",  # "X" で始まる特徴 -> Metabolome
      grepl("^Dry", name) ~ "Phenotype",  # "Dry" で始まる特徴 -> Phenotype
      TRUE ~ "Other"  # その他は "Other"
    )
  )

node_colors <- c("Genome" = "#FF6F61",  # soft red-orange
                 "Microbiome" = "#66B032",  # soft green
                 "Metabolome" = "#4B8BBE",  # soft blue
                 "Phenotype" = "#9B4F96",  # soft purple
                 "Other" = "#B0B0B0")  # light grey

# 3. igraph グラフを作成
g <- graph_from_data_frame(d = edges_df, vertices = nodes, directed = FALSE)

# 4. プロット
ggraph(g, layout = "fr") +  
  geom_edge_link(aes(width = abs(weight)), color = "gray", alpha = 0.8) +  # エッジの色を固定 (gray) & 太さ (abs(weight)で色と太さを調整)
  geom_node_point(aes(color = type), size = 5) +  # ノードの色をタイプに基づいて変更
  geom_node_text(aes(label = name), repel = TRUE) +  # ラベルを feature 名に修正
  scale_edge_width(range = c(0.5, 2)) +  # エッジの太さを調整
  scale_color_manual(values = node_colors) +  # ノードの色を設定 (タイプに基づいて色分け)
  theme_void() +
  theme(legend.position = "right")  # 凡例の位置を右に設定

```






```{r}
# Assuming 'predictor' is the Predictor object you have created with the ranger model

# Assuming 'predictor' is already defined
shap_interactions <- Shapley$new(predictor, x.interest = X[1, , drop = FALSE])

# Extract SHAP interaction results
shap_interactions_values <- shap_interactions$results$interaction

# Convert interaction values to a data frame
shap_interactions_df <- as.data.frame(shap_interactions_values)

# Reshape the data frame into a long format for plotting
library(tidyr)
shap_interactions_long <- pivot_longer(shap_interactions_df, 
                                       cols = everything(), 
                                       names_to = "feature_pair", 
                                       values_to = "interaction_value")
# Create a plot of the interactions
interaction_plot <- ggplot(shap_interactions_long, aes(x=feature_pair, y=interaction_value, fill=interaction_value)) +
  geom_tile() +
  labs(title="Feature Interactions - SHAP", x="Feature Pair", y="Interaction Value", fill="Interaction Value") +
  theme_minimal()

print(interaction_plot)



```




sim
```{r}

set.seed(123)
n <- 20  # サンプル数
p <- 20  # 説明変数の数
phenotypes <- 9  # 形質の数


X <- as.data.frame(matrix(rnorm(n * p), nrow=n, ncol=p))
colnames(X) <- paste0("Var", 1:p)

Y <- as.data.frame(matrix(rnorm(n * phenotypes), nrow=n, ncol=phenotypes))
colnames(Y) <- paste0("Pheno", 1:phenotypes)




# SHAP の結果を保存するリスト
shap_results <- list()

for (i in 1:phenotypes) {
  cat("Processing phenotype:", colnames(Y)[i], "\n")

  # 形質ごとにランダムフォレストの importance で特徴選択
  imp_vars <- colnames(X)  # ここでは全変数を使用するが、重要度が高い変数だけを選んでもよい
# 目的変数の名前を保持してデータ統合
df <- data.frame(X)
df[[colnames(Y)[i]]] <- Y[[i]]  # 目的変数の列名を正しく設定

# ranger を使ってモデルを再学習
rf_model <- ranger(
  formula = as.formula(paste(colnames(Y)[i], "~ .")),  # 目的変数を明示
  data = df,  # 目的変数の名前を正しく含めたデータ
  num.trees = 100
)



  # iml の Predictor オブジェクトを作成
  predictor <- Predictor$new(rf_model, data=X, y=Y[[i]])

  # SHAP の計算 (サンプルの一部で計算)
  shapley <- Shapley$new(predictor, x.interest=X[1, , drop=FALSE])
  shap_values <- shapley$results

  # 結果をリストに保存
  shap_results[[colnames(Y)[i]]] <- shap_values
}

# SHAP の可視化 (例: 最初の形質に対する SHAP 影響度)
shap_df <- as.data.frame(shap_results[[colnames(Y)[1]]])

# プロット
ggplot(shap_df, aes(x=phi, y=feature.value, color=feature)) +
  geom_point() +
  labs(title=paste("SHAP Values for", colnames(Y)[1]),
       x="SHAP Value",
       y="Feature Value") +
  theme_minimal()

```

```{r}

shap_df <- as.data.frame(shap_results[[colnames(Y)[1]]])  # 例: 最初の形質
colnames(shap_df) <- c("feature", "phi", "feature_value")

# プロット
ggplot(shap_df, aes(x=reorder(feature, phi, FUN=median), y=phi)) +
  geom_boxplot() +
  coord_flip() +
  labs(title=paste("SHAP Distribution for", colnames(Y)[1]),
       x="Feature",
       y="SHAP Value") +
  theme_minimal()

# 例: 特定の変数（Var10）に対する SHAP 散布図
ggplot(shap_df[shap_df$feature == "Var10", ], aes(x=feature_value, y=phi)) +
  geom_point(alpha=0.5) +
  geom_smooth(method="lm", color="blue") +
  labs(title=paste("SHAP Dependence Plot for Var10"),
       x="Feature Value (Var10)",
       y="SHAP Value") +
  theme_minimal()
ggplot(shap_df, aes(x=phi, y=reorder(feature, phi, FUN=median), color=feature_value)) +
  geom_point(alpha=0.6) +
  scale_color_gradient(low="blue", high="red") +
  labs(title=paste("SHAP Summary Plot for", colnames(Y)[1]),
       x="SHAP Value",
       y="Feature") +
  theme_minimal()

shap_importance <- aggregate(phi ~ feature, data=shap_df, FUN=sum)

ggplot(shap_importance, aes(x=reorder(feature, phi), y=phi)) +
  geom_bar(stat="identity", fill="steelblue") +
  coord_flip() +
  labs(title=paste("SHAP Feature Importance for", colnames(Y)[1]),
       x="Feature",
       y="Total SHAP Value") +
  theme_minimal()

```
