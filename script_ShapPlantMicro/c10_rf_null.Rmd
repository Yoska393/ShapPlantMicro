
from 58

```{r, message =F}
require(BGLR)
library(dplyr)
require(here)
require(ggplot2)
require(reshape2)
# require(gridExtra)
# library(readr)
library(stringr)
# library(ggsci)
library(RAINBOWR)
# library(lubridate)
library(foreach)
library(future)
library(doFuture)
# library(doRNG)
library(tictoc)
library(doSNOW)
library(purrr)
source("Script/MyFunctions.R")

require(ranger)
require(ggrepel)
# require(tidyverse)
library(rrda)

library(ggrepel)
library(grid) 
library(ranger)
library(caret)
getwd()
```

seed
```{r, message =F}
seedIndCsv <-  here("out","seedInd.csv")
if (file.exists(seedIndCsv)) {
  seedInd <- read.csv(seedIndCsv, row.names = 1, header = T)
  seedInd <- c(as.matrix(seedInd))
} else {
  seedInd <- sample(1:500, 10, replace = F)
  write.csv(x = seedInd, file =  here("out","seedInd.csv"))
}
```

```{r}
cd = "Drought"

if (cd == "Drought"){
	CD<-"W4"
	Data<-readRDS(here("data/SoyData_Drought2.RDS"))
} else if (cd=="Control"){
	CD<-"W1"
	Data<-readRDS(here("data/SoyData_Control2.RDS"))
} else{
	stop()
}


genome<-Data$genome
grm.cd<-Data$grm
met.cd<-Data$met
mic.cd<-Data$mic
mir.cd<-Data$mir
psc19<-Data$pheno
miname<-Data$microname
metname<-Data$metname
cd<-Data$cd

genome<- scale(genome)
met.cd<-scale(met.cd)
mic.cd <- scale(mic.cd)
psc19 <- scale(psc19)

dim(mic.cd)
dim(met.cd)
# 
# mi_df    <- data.frame(mic.cd)
# met_df   <-  data.frame(met.cd)
# pheno_df <- data.frame(pheno.cd = psc19)
# 
# write.csv(mi_df,    file = paste0("omics_csv/micro_", cd, ".csv"), row.names = T)
# write.csv(met_df,   file = paste0("omics_csv/met_", cd, ".csv"),   row.names = T)
# write.csv(pheno_df, file = paste0("omics_csv/pheno_", cd, ".csv"), row.names = T)
# 
# 
# miname_df <- data.frame(miname = miname)
# write.csv(miname_df, file = "miname.csv", row.names = T)
# 
# metname_df <- data.frame(metname = metname)
# write.csv(metname_df, file = "metname.csv", row.names = T)

```


# RF for pheno

prepare datasets
```{r}
X.list <- vector("list", 7)
X.list[[1]] <- genome
X.list[[2]] <- mic.cd
X.list[[3]] <- cbind(genome, mic.cd)
X.list[[4]] <- met.cd
X.list[[5]] <- cbind(genome, met.cd)
X.list[[6]] <- cbind(mic.cd, met.cd)
X.list[[7]] <- cbind(genome, mic.cd, met.cd)
names(X.list) <- c("G",
                "M",
                "GM",
                "Met",
                "GMet",
                "MMet", 
                "GMMet")

```


```{r}
colnames(psc19)<- c("LeafDryWeight", "ShootDryWeight",
                          "ShootFreshWeight", "LeafFreshWeight",
                          "GrowthStage", "NumberOfNodes",
                          "NumberOfBranches", "PlantHeight", "MainStemLength")
```



```{r}
library(ranger)

set.seed(123)


Y <- as.data.frame(psc19)    # 9 traits
X <- as.matrix(X.list[[7]])  
n <- nrow(Y)


k_cv      <- 10     # 10-fold CV
repeats   <- 3    # 5 repeats → 50 CV R² if repeats*k_cv
B_perm    <- 100    # permutation 
num.trees <- 500    # tree


res_list <- vector("list", ncol(Y))
names(res_list) <- colnames(Y)


for (j in seq_len(ncol(Y))) {

  trait <- colnames(Y)[j]
  y     <- Y[[j]]

  cat("=== Trait:", trait, "===\n")


  cv_r2 <- c()

  for (r in 1:repeats) {
    folds <- sample(rep(1:k_cv, length.out = n))

    for (i in 1:k_cv) {
      train_idx <- which(folds != i)
      test_idx  <- which(folds == i)

      fit <- ranger(
        y = y[train_idx],
        x = X[train_idx, , drop = FALSE],
        num.trees    = num.trees,
        importance   = "none",
        write.forest = TRUE
      )

      pred    <- predict(fit, data = X[test_idx, , drop = FALSE])$predictions
      r2_fold <- cor(pred, y[test_idx])^2
      cv_r2   <- c(cv_r2, r2_fold)
    }
  }

  mean_cv_r2 <- mean(cv_r2)
  se_cv_r2   <- sd(cv_r2) / sqrt(length(cv_r2))

  cat("  mean R² =", round(mean_cv_r2, 3),
      "  SE =", round(se_cv_r2, 3), "\n")

  ## -------------------------
  ## (2) permutation-based null distribution of R²
  ## -------------------------
  null_r2 <- numeric(B_perm)

  for (b in 1:B_perm) {
    y_perm <- sample(y)
    folds  <- sample(rep(1:k_cv, length.out = n))
    r2_b   <- c()

    for (i in 1:k_cv) {
      train_idx <- which(folds != i)
      test_idx  <- which(folds == i)

      fit_perm <- ranger(
        y = y_perm[train_idx],
        x = X[train_idx, , drop = FALSE],
        num.trees    = num.trees,
        importance   = "none",
        write.forest = TRUE
      )

      pred_perm    <- predict(fit_perm, data = X[test_idx, , drop = FALSE])$predictions
      r2_fold_perm <- cor(pred_perm, y_perm[test_idx])^2
      r2_b         <- c(r2_b, r2_fold_perm)
    }

    null_r2[b] <- mean(r2_b)

    if (b %% 10 == 0) {
      cat("  Permutation", b, "finished\n")
    }
  }


  res_list[[j]] <- list(
    trait      = trait,
    cv_r2      = cv_r2,
    mean_cv_r2 = mean_cv_r2,
    se_cv_r2   = se_cv_r2,
    null_r2    = null_r2
  )
}

saveRDS(res_list, here::here("out", "null_rf_all_traits.rds"))

```


```{r}
library(ggplot2)

res_list <- readRDS(here::here("out", "null_rf_all_traits.rds"))


df_null_all <- do.call(rbind, lapply(res_list, function(x) {
  data.frame(
    trait   = x$trait,
    null_r2 = x$null_r2
  )
}))

df_stats <- do.call(rbind, lapply(res_list, function(x) {
  mean_cv_r2 <- x$mean_cv_r2
  se_cv_r2   <- x$se_cv_r2
  data.frame(
    trait      = x$trait,
    mean_cv_r2 = mean_cv_r2,
    lower      = mean_cv_r2 - 1.96 * se_cv_r2,
    upper      = mean_cv_r2 + 1.96 * se_cv_r2
  )
}))

## trait -> factor 
# df_null_all$trait <- factor(df_null_all$trait, levels = colnames(Y))
# df_stats$trait    <- factor(df_stats$trait,    levels = colnames(Y))


p_all <- ggplot(df_null_all, aes(x = null_r2)) +
  geom_histogram(
    bins = 40,
    fill = "gray85",
    color = "black"
  ) +
  ## 95% CI 
  geom_rect(
    data = df_stats,
    aes(
      xmin = lower,
      xmax = upper,
      ymin = 0,
      ymax = Inf
    ),
    inherit.aes = FALSE,
    alpha = 0.18,
    fill  = "red"
  ) +
  
  geom_vline(
    data = df_stats,
    aes(xintercept = mean_cv_r2),
    color = "red",
    size  = 0.9
  ) +
  facet_wrap(~ trait, scales = "free_x") +
  labs(
    x = "Cross-validated R²",
    y = "Count",
    title = "Permutation-based null distributions and real-data R² (mean ± 95% CI) for all traits"
  ) +
  theme_minimal(base_size = 13)

p_all



```

