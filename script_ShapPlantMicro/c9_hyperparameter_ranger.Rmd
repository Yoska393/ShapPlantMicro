---
title: "c9_hyperparameter"
author: "Hayato Yoshioka"
date: "2025-08-05"
output: html_document
---

```{r, message =F}
require(BGLR)
library(dplyr)
require(here)
require(ggplot2)
require(reshape2)
# require(gridExtra)
# library(readr)
library(stringr)
# library(ggsci)
library(RAINBOWR)
# library(lubridate)
library(foreach)
library(future)
library(doFuture)
# library(doRNG)
library(tictoc)
library(doSNOW)
library(purrr)
source("Script/MyFunctions.R")

require(ranger)
require(ggrepel)
# require(tidyverse)
library(rrda)

library(ggrepel)
library(grid) 

getwd()
```

seed
```{r, message =F}
seedIndCsv <-  here("out","seedInd.csv")
if (file.exists(seedIndCsv)) {
  seedInd <- read.csv(seedIndCsv, row.names = 1, header = T)
  seedInd <- c(as.matrix(seedInd))
} else {
  seedInd <- sample(1:500, 10, replace = F)
  write.csv(x = seedInd, file =  here("out","seedInd.csv"))
}
```

```{r}

cd2 = c("Drought","Control")

for (cd in cd2){
	
if (cd == "Drought"){
	CD<-"W4"
	Data<-readRDS(here("data/SoyData_Drought2.RDS"))
} else if (cd=="Control"){
	CD<-"W1"
	Data<-readRDS(here("data/SoyData_Control2.RDS"))
} else{
	stop()
}


genome<-Data$genome
grm.cd<-Data$grm
met.cd<-Data$met
mic.cd<-Data$mic
mir.cd<-Data$mir
psc19<-Data$pheno
miname<-Data$microname
metname<-Data$metname
cd<-Data$cd

genome<- scale(genome)
met.cd<-scale(met.cd)
mic.cd <- scale(mic.cd)
psc19 <- scale(psc19)

dim(mic.cd)
dim(met.cd)


set.seed(123)
Y <- psc19
X <- cbind(genome, mic.cd, met.cd)

# Y <- Y[c(1:20),c(1:5)]
# X <- X[c(1:20),c(1:20)]

iterations <- ncol(Y)  # number of traits

# Define hyperparameter grids
mtry.grid <- c(floor(ncol(X) / 6), floor(ncol(X) / 3), floor(ncol(X) / 1.5))
min.node.size.grid <- c(3, 5, 7)
num.trees.grid <- c(100, 500, 1000)

param.grid <- expand.grid(
  mtry = mtry.grid,
  min.node.size = min.node.size.grid,
  num.trees = num.trees.grid
)


# Start parallel cluster
cl <- makeCluster(10)
registerDoSNOW(cl)

# Progress bar
pb <- txtProgressBar(max = iterations, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

# Start timer
tic()

# Run tuning with foreach
all.results <- foreach(i = 1:iterations, .packages = c("ranger", "caret"), .options.snow = opts) %dopar% {
  y <- as.numeric(Y[, i])
  dat <- data.frame(y = y, X)
  n <- nrow(dat)

  set.seed(123)
  folds <- createFolds(y, k = 10, list = TRUE)

  results <- data.frame()

  for (k in 1:nrow(param.grid)) {
    mtry.val <- param.grid$mtry[k]
    node.val <- param.grid$min.node.size[k]
    trees.val <- param.grid$num.trees[k]

    fold.mse <- numeric(length(folds))

    for (j in seq_along(folds)) {
      test.idx <- folds[[j]]
      train.idx <- setdiff(seq_len(n), test.idx)

      model <- ranger(
        y ~ ., data = dat[train.idx, ],
        mtry = mtry.val,
        min.node.size = node.val,
        num.trees = trees.val
      )

      preds <- predict(model, data = dat[test.idx, ])$predictions
      fold.mse[j] <- mean((y[test.idx] - preds)^2)
    }

    # Store raw fold-level MSEs (as list column)
    results <- rbind(results, data.frame(
      trait = colnames(Y)[i],
      mtry = mtry.val,
      min.node.size = node.val,
      num.trees = trees.val,
      fold.mse = I(list(fold.mse))  # store as list-column
    ))
  }

  results
}

# Stop parallel processing
close(pb)
stopCluster(cl)
toc()

# Combine all trait results
all.results.df <- do.call(rbind, all.results)

# Save full fold-level results
saveRDS(all.results.df, here("out", paste0("tune_folds_RF_", CD, "pheno_mse.rds")))

# === Aggregate properly: compute global mean and SD over all folds across traits ===
summary.stats <- all.results.df %>%
  group_by(mtry, min.node.size, num.trees) %>%
  summarise(
    all_fold_mse = list(unlist(fold.mse)), .groups = "drop"
  ) %>%
  mutate(
    mse.mean = sapply(all_fold_mse, mean),
    mse.sd   = sapply(all_fold_mse, sd)
  ) %>%
  select(-all_fold_mse)

# Save summary stats
saveRDS(summary.stats, here("out", paste0("tune_summary_RF_", CD, "pheno_mse.rds")))

}
```


```{r}
stats <- readRDS(here("out", paste0("tune_summary_RF_", CD, "pheno_mse.rds")))



for (CD in c("W1","W4")){
	

results <- readRDS(here("out", paste0("tune_folds_RF_", CD, "pheno_mse.rds")))



results<-results[1:27,]

# === Aggregate properly: compute global mean and SD over all folds across traits ===
summary.stats <- results %>%
  group_by(mtry, min.node.size, num.trees) %>%
  summarise(
    all_fold_mse = list(unlist(fold.mse)), .groups = "drop"
  ) %>%
  mutate(
    mse.mean = sapply(all_fold_mse, mean),
    mse.sd   = sapply(all_fold_mse, sd)
  ) %>%
  select(-all_fold_mse)



saveRDS(summary.stats, here("out", paste0("tune_summary_RF_", CD, "pheno_mse_dryweight.rds")))
}
```



```{r,fig.height=8,fig.width=14}
library(ggplot2)
library(dplyr)
library(tidyr)
library(forcats)
library(here)
library(ggplot2)
library(dplyr)
library(tidyr)
library(forcats)
library(here)
library(ggtext)  # ← 必要！

set.seed(123)
#Y <- psc19
#X <- cbind(genome, mic.cd, met.cd)

# Y <- Y[c(1:20),c(1:5)]
# X <- X[c(1:20),c(1:20)]

#iterations <- ncol(Y)  # number of traits

# Define hyperparameter grids
mtry.name <- c("p/6","p/3","p/1.5")
# min.node.size.grid <- c(3, 5, 7)
# num.trees.grid <- c(100, 500, 1000)


# --- デフォルトパラメータ強調用 ---
default_param <- "mtry=p/3, node=5, trees=100"


# === Load both W4 and W1 ===
conditions <- c("W4", "W1")
summary_list <- list()



for (CD in conditions) {
  stats <- readRDS(here("out", paste0("tune_summary_RF_", CD, "pheno_mse.rds")))
	stats$mtry[1:9]<-mtry.name[1]
	stats$mtry[10:18]<-mtry.name[2]
	stats$mtry[19:27]<-mtry.name[3]
   
  stats$condition <- CD
  summary_list[[CD]] <- stats
}


# === STEP 1: 結合
df_combined <- bind_rows(summary_list$W1, summary_list$W4)

# === STEP 2: 平均（27通りあるはず）
summary_avg <- df_combined %>%
  group_by(mtry, min.node.size, num.trees) %>%
  summarise(
    mse.mean = mean(mse.mean),
    mse.sd = sqrt(mean(mse.sd^2)),
    condition = "Average MSE (Both Conditions)",
    .groups = "drop"
  )

# === STEP 3: 結合
df_all <- bind_rows(df_combined, summary_avg)

# === STEP 4: param_id列の作成（x軸ラベルに使う）
df_all <- df_all %>%
  mutate(param_id = paste0("mtry=", mtry, ", node=", min.node.size, ", trees=", num.trees))

# === STEP 5: param_id の並び順を平均MSEに基づいて設定
avg_order <- df_all %>%
  filter(condition == "Average MSE (Both Conditions)") %>%
  arrange(mse.mean) %>%
  pull(param_id)

df_all <- df_all %>%
  mutate(param_id = factor(param_id, levels = avg_order))

# === STEP 6: デフォルトパラメータの表示用ラベル（*付き）
default_param <- "mtry=p/3, node=5, trees=100"
df_all <- df_all %>%
  mutate(label_display = ifelse(param_id == default_param, paste0("*", param_id), as.character(param_id)))

# === Define custom condition labels and order ===
df_all$condition <- recode(df_all$condition,
                           "W4" = "Drought MSE",
                           "W1" = "Control MSE",
                           "Average" = "Average MSE (Both Conditions)")

# Set condition factor levels to control both legend and bar order
df_all$condition <- factor(df_all$condition, 
                           levels = c("Drought MSE", "Control MSE", "Average MSE (Both Conditions)"))

# Updated manual colors for matching labels
condition_colors <- c(
  "Drought MSE" = "#ff7f0e",          # orange
  "Control MSE" = "#1f77b4",          # blue
  "Average MSE (Both Conditions)" = "#7f7f7f"  # gray
)

# === Plot ===
ggplot(df_all, aes(x = label_display, y = mse.mean, fill = condition)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = mse.mean - mse.sd, ymax = mse.mean + mse.sd),
                position = position_dodge(width = 0.8), width = 0.2, color = "black") +
  scale_fill_manual(values = condition_colors) +
  labs(
    title = "Top Parameter Sets with Error Bars",
    x = "Parameter Setting",
    y = "Mean Squared Error (MSE)",
    fill = "Condition"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1),
    plot.title = element_text(face = "bold"),
    legend.position = "top"
  )

write.csv(df_all, "out/tuning_summary_combined.csv", row.names = FALSE)
```

```{python,fig.height=8,fig.width=14}
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# === Load Data ===
df_all = pd.read_csv("out/tuning_summary_combined.csv")

# === Ensure correct order for param_id (based on Average MSE) ===
avg_order = (
    df_all[df_all["condition"] == "Average MSE (Both Conditions)"]
    .sort_values("mse.mean")
    .param_id
    .tolist()
)

df_all["param_id"] = pd.Categorical(df_all["param_id"], categories=avg_order, ordered=True)

# === Highlight default parameter (mtry=5, node=5, trees=100)
default_label = "mtry=p/3, node=5, trees=500"

df_all["label_display"] = df_all["param_id"].apply(
    lambda x: f"$\\bf{{{x}}}$" if x == default_label else x
)

# === Set colors (same as R)
condition_colors = {
    "Drought MSE": "#ff7f0e",   # orange
    "Control MSE": "#1f77b4",   # blue
    "Average MSE (Both Conditions)": "#7f7f7f"  # gray
}

# === Prepare Plot ===
fig, ax = plt.subplots(figsize=(16, 8))

x = np.arange(len(avg_order))
width = 0.25

# Split by condition
conds = ["Drought MSE", "Control MSE", "Average MSE (Both Conditions)"]
offsets = [-width, 0, width]

for cond, offset in zip(conds, offsets):
    df_sub = df_all[df_all["condition"] == cond].sort_values("param_id")
    ax.bar(
        x + offset,
        df_sub["mse.mean"],
        width,
        yerr=df_sub["mse.sd"],
        capsize=2,
        label=cond,
        color=condition_colors[cond]
    )

# Format x-ticks
tick_labels = df_all[df_all["condition"] == "Drought MSE"].sort_values("param_id")["label_display"]
ax.set_xticks(x)
ax.set_xticklabels(tick_labels, rotation=60, ha="right")

# Title and labels
ax.set_title("HyperParameter Sets for $\mathbf{ranger}$", fontsize=16)
ax.set_ylabel("Mean Squared Error (MSE)")

# Legend at top-left
ax.legend(
    loc="upper left",
    bbox_to_anchor=(0, 1),
    frameon=False,
    title=""
)
ax.set_ylim(top=1.3)
# Grid styling
ax.grid(False)
ax.yaxis.grid(True, linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()

```

